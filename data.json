[
  {
    "col_1": 1,
    "col_2": "Which of the following is the correct syntax of including a user defined header files in C++?",
    "col_3": "#include <userdefined.h>",
    "col_4": "#include <userdefined>",
    "col_5": "#include \"userdefined",
    "col_6": "#include [userdefined]",
    "col_7": "#include \"userdefined",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 2,
    "col_2": "Which of the following is a correct identifier in C++?",
    "col_3": "7var_name",
    "col_4": "7VARNAME",
    "col_5": "VAR_1234",
    "col_6": "$var_name",
    "col_7": "VAR_1234",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 3,
    "col_2": "Which of the following is called address operator?",
    "col_3": "*",
    "col_4": "&",
    "col_5": "_",
    "col_6": "%",
    "col_7": "&",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 4,
    "col_2": "Which of the following is used for comments in C++?",
    "col_3": "// comment",
    "col_4": "/* comment */",
    "col_5": "both // comment or /* comment */",
    "col_6": "// comment */",
    "col_7": "both // comment or /* comment */",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 5,
    "col_2": "What are the actual parameters in C++?",
    "col_3": "Parameters with which functions are called",
    "col_4": "Parameters which are used in the definition of a function",
    "col_5": "Variables other than passed parameters in a function",
    "col_6": "Variables that are never used in the function",
    "col_7": "Parameters with which functions are called",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 6,
    "col_2": "What are the formal parameters in C++?",
    "col_3": "Parameters with which functions are called",
    "col_4": "Parameters which are used in the definition of the function",
    "col_5": "Variables other than passed parameters in a function",
    "col_6": "Variables that are never used in the function",
    "col_7": "Parameters which are used in the definition of the function",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 7,
    "col_2": "Which function is used to read a single character from the console in C++?",
    "col_3": "cin.get(ch)",
    "col_4": "getline(ch)",
    "col_5": "read(ch)",
    "col_6": "scanf(ch)",
    "col_7": "cin.get(ch)",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 8,
    "col_2": "Which function is used to write a single character to console in C++?",
    "col_3": "cout.put(ch)",
    "col_4": "cout.putline(ch)",
    "col_5": "write(ch)",
    "col_6": "printf(ch)",
    "col_7": "cout.put(ch)",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 9,
    "col_2": "What are the escape sequences?",
    "col_3": "Set of characters that convey special meaning in a program",
    "col_4": "Set of characters that whose use are avoided in C++ programs",
    "col_5": "Set of characters that are used in the name of the main function of the program",
    "col_6": "Set of characters that are avoided in cout statements",
    "col_7": "Set of characters that convey special meaning in a program",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 10,
    "col_2": "Who created C++?",
    "col_3": "Bjarne Stroustrup",
    "col_4": "Dennis Ritchie",
    "col_5": "Ken Thompson",
    "col_6": "Brian Kernighan",
    "col_7": "Bjarne Stroustrup",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 11,
    "col_2": "Which of the following is called insertion/put to operator?",
    "col_3": "<<",
    "col_4": ">>",
    "col_5": ">",
    "col_6": "<",
    "col_7": "<<",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 12,
    "col_2": "Which of the following is called insertion/put to operator?",
    "col_3": "<<",
    "col_4": ">>",
    "col_5": ">",
    "col_6": "<",
    "col_7": ">>",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 13,
    "col_2": "A language which has the capability to generate new data types are called ________________",
    "col_3": "Extensible",
    "col_4": "Overloaded",
    "col_5": "Encapsulated",
    "col_6": "Reprehensible",
    "col_7": "Extensible",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 14,
    "col_2": "Wrapping data and its related functionality into a single entity is known as _____________",
    "col_3": "Abstraction",
    "col_4": "Encapsulation",
    "col_5": "Polymorphism",
    "col_6": "Modularity",
    "col_7": "Encapsulation",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 15,
    "col_2": "How structures and classes in C++ differ?",
    "col_3": "Classes follows OOP concepts whereas structure does not",
    "col_4": "In Structures, members are private by default whereas in Classes they are public by default",
    "col_5": "Structures by default hide every member",
    "col_6": "Classes and Structures are the same",
    "col_7": "Classes follows OOP concepts whereas structure does not",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 16,
    "col_2": "What does polymorphism in OOPs mean?",
    "col_3": "Concept of allowing overiding of functions",
    "col_4": "Concept of hiding data",
    "col_5": "Concept of keeping things in differnt modules/files",
    "col_6": "Concept of wrapping things into a single unit",
    "col_7": "Concept of allowing overiding of functions",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 17,
    "col_2": "Which concept allows you to reuse the written code?",
    "col_3": "Encapsulation",
    "col_4": "Abstraction",
    "col_5": "Inheritance",
    "col_6": "Polymorphism",
    "col_7": "Inheritance",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 18,
    "col_2": "Which of the following shows multiple inheritances?",
    "col_3": "A->B->C",
    "col_4": "A->B; A->C",
    "col_5": "A,B->C",
    "col_6": "B->A",
    "col_7": "A,B->C",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 19,
    "col_2": "How access specifiers in Class helps in Abstraction?",
    "col_3": "They does not helps in any way",
    "col_4": "They allows us to show only required things to outer world",
    "col_5": "They help in keeping things together",
    "col_6": "Abstraction concept is not used in classes",
    "col_7": "They allows us to show only required things to outer world",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 20,
    "col_2": "C++ is ______________",
    "col_3": "procedural programming language",
    "col_4": "object oriented programming language",
    "col_5": "functional programming language",
    "col_6": "both procedural and object oriented programming language",
    "col_7": "both procedural and object oriented programming language",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 21,
    "col_2": "What does modularity mean?",
    "col_3": "Hiding part of program",
    "col_4": "Subdividing program into small independent parts",
    "col_5": "Overriding parts of program",
    "col_6": "Wrapping things into single unit",
    "col_7": "Subdividing program into small independent parts",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 22,
    "col_2": "Which of the following class allows to declare only one object of it?",
    "col_3": "Abstract class",
    "col_4": "Virtual class",
    "col_5": "Singleton class",
    "col_6": "Friend class",
    "col_7": "Singleton class",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 23,
    "col_2": "Which of the following is not a type of Constructor?",
    "col_3": "Friend constructor",
    "col_4": "Copy constructor",
    "col_5": "Default constructor",
    "col_6": "Parameterized constructor",
    "col_7": "Friend constructor",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 24,
    "col_2": "Which of the following is correct?",
    "col_3": "Base class pointer object cannot point to a derived class object",
    "col_4": "Derived class pointer object cannot point to a base class object",
    "col_5": "A derived class cannot have pointer objects",
    "col_6": "A base class cannot have pointer objects",
    "col_7": "Derived class pointer object cannot point to a base class object",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 25,
    "col_2": "Out of the following, which is not a member of the class?",
    "col_3": "Static function",
    "col_4": "Friend function",
    "col_5": "Constant function",
    "col_6": "Virtual function",
    "col_7": "Friend function",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 26,
    "col_2": "What is the other name used for functions inside a class?",
    "col_3": "Member variables",
    "col_4": "Member functions",
    "col_5": "Class functions",
    "col_6": "Class variables",
    "col_7": "Member functions",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 27,
    "col_2": "Which of the following cannot be a friend?",
    "col_3": "Function",
    "col_4": "Class",
    "col_5": "Object",
    "col_6": "Operator function",
    "col_7": "Object",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 28,
    "col_2": "Why references are different from pointers?",
    "col_3": "A reference cannot be made null",
    "col_4": "A reference cannot be changed once initialized",
    "col_5": "No extra operator is needed for dereferencing of a reference",
    "col_6": "All of the mentioned",
    "col_7": "All of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 29,
    "col_2": "Which of the following provides a programmer with the facility of using object of a class inside other classes?",
    "col_3": "Inheritance",
    "col_4": "Composition",
    "col_5": "Abstraction",
    "col_6": "Encapsulation",
    "col_7": "Composition",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 30,
    "col_2": "How many types of polymorphism are there in C++?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 2,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 31,
    "col_2": "How run-time polymorphisms are implemented in C++?",
    "col_3": "Using Inheritance",
    "col_4": "Using Virtual functions",
    "col_5": "Using Templates",
    "col_6": "Using Inheritance and Virtual functions",
    "col_7": "Using Inheritance and Virtual functions",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 32,
    "col_2": "How compile-time polymorphisms are implemented in C++?",
    "col_3": "Using Inheritance",
    "col_4": "Using Virtual functions",
    "col_5": "Using Templates",
    "col_6": "Using Inheritance and Virtual functions",
    "col_7": "Using Templates",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 33,
    "col_2": "Which of the following is an abstract data type?",
    "col_3": "int",
    "col_4": "float",
    "col_5": "class",
    "col_6": "string",
    "col_7": "class",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 34,
    "col_2": "Which concept means the addition of new components to a program as it runs?",
    "col_3": "Data hiding",
    "col_4": "Dynamic binding",
    "col_5": "Dynamic loading",
    "col_6": "Dynamic typing",
    "col_7": "Dynamic loading",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 35,
    "col_2": "Which of the following explains the overloading of functions?",
    "col_3": "Virtual polymorphism",
    "col_4": "Transient polymorphism",
    "col_5": "Ad-hoc polymorphisms) Pseudo polymorphism",
    "col_6": "None of the mentioned",
    "col_7": "Ad-hoc polymorphisms) Pseudo polymorphism",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 36,
    "col_2": "Which of the following approach is used by C++?",
    "col_3": "Top-down",
    "col_4": "Bottom-up",
    "col_5": "Left-right",
    "col_6": "Right-left",
    "col_7": "Bottom-up",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 37,
    "col_2": "Which operator is overloaded for a cout object?",
    "col_3": ">>",
    "col_4": "<<",
    "col_5": "<",
    "col_6": ">",
    "col_7": "<<",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 38,
    "col_2": "Which of the following cannot be used with the virtual keyword?",
    "col_3": "Class",
    "col_4": "Member functions",
    "col_5": "Constructors",
    "col_6": "Destructors",
    "col_7": "Constructors",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 39,
    "col_2": "Which concept is used to implement late binding?",
    "col_3": "Virtual functions",
    "col_4": "Operator functions",
    "col_5": "Constant functions",
    "col_6": "Static functions",
    "col_7": "Virtual functions",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 40,
    "col_2": "Which of the following is correct?",
    "col_3": "C++ allows static type checking",
    "col_4": "C++ allows dynamic type checking.",
    "col_5": "C++ allows static member function to be of type const.",
    "col_6": "C++ allows both static and dynamic type checking",
    "col_7": "C++ allows both static and dynamic type checking",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 41,
    "col_2": "Which of the following supports the concept that reusability is a desirable feature of a language?",
    "col_3": "It reduces the testing time",
    "col_4": "It reduces maintenance cost",
    "col_5": "It decreases the compilation time",
    "col_6": "It reduced both testing and maintenance time",
    "col_7": "It reduced both testing and maintenance time",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 42,
    "col_2": "Which of the following is a static polymorphism mechanism?",
    "col_3": "Function overloading",
    "col_4": "Operator overloading",
    "col_5": "Templates",
    "col_6": "All of the mentioned",
    "col_7": "All of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 43,
    "col_2": "Which of the following is true?I) All operators in C++ can be overloaded.II) The basic meaning of an operator can be changed.",
    "col_3": "I only",
    "col_4": "II only",
    "col_5": "Both I and II",
    "col_6": "Neither I nor II",
    "col_7": "Neither I nor II",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 44,
    "col_2": "Which of the following is not a type of inheritance?",
    "col_3": "Multiple",
    "col_4": "Multilevel",
    "col_5": "Distributive",
    "col_6": "Hierarchical",
    "col_7": "Distributive",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 45,
    "col_2": "What happens if a class does not have a name?",
    "col_3": "It will not have a constructor",
    "col_4": "It will not have a destructor",
    "col_5": "It is not allowed",
    "col_6": "It will neither have a constructor or destructor",
    "col_7": "It will not have a destructor",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 46,
    "col_2": "Which of the following statement is true?I) In Procedural programming languages, all function calls are resolved at compile-timeII) In Object Oriented programming languages, all function calls are resolved at compile-time",
    "col_3": "I only",
    "col_4": "II only",
    "col_5": "Both I and II",
    "col_6": "Neither I nor II",
    "col_7": "I only",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 47,
    "col_2": "Which members are inherited but are not accessible in any case?",
    "col_3": "Private",
    "col_4": "Public",
    "col_5": "Protected",
    "col_6": "Both private and protected",
    "col_7": "Private",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 48,
    "col_2": "Which of the following is correct?",
    "col_3": "Friend functions can access public members of a class",
    "col_4": "Friend functions can access protected members of a class",
    "col_5": "Friend functions can access private members of a class",
    "col_6": "All of the mentioned",
    "col_7": "All of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 49,
    "col_2": "Which of the following is correct in C++?",
    "col_3": "Classes cannot have protected data members",
    "col_4": "Structures can have member functions",
    "col_5": "Class members are public by default",
    "col_6": "Structure members are private by default",
    "col_7": "Structures can have member functions",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 50,
    "col_2": "Which of the following is used to make an abstract class?",
    "col_3": "By using virtual keyword in front of a class declaration",
    "col_4": "By using an abstract keyword in front of a class declaration",
    "col_5": "By declaring a virtual function in a class",
    "col_6": "By declaring a pure virtual function in a class",
    "col_7": "By declaring a pure virtual function in a class",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 51,
    "col_2": "Which of the following is correct?",
    "col_3": "A class is an instance of its objects",
    "col_4": "An object is an instance of its class",
    "col_5": "A class is an instance of the data type that the class have",
    "col_6": "An object is an instance of the data type of the class",
    "col_7": "An object is an instance of its class",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 52,
    "col_2": "Which of the following is correct about new and malloc?",
    "col_3": "Both are available in C",
    "col_4": "Pointer object initialization of a class with both new and malloc calls the constructor of that class",
    "col_5": "Pointer object initialization of a class using new involves constructor call whereas using malloc does not involve constructor call",
    "col_6": "Pointer object initialization of a class using malloc involves constructor call whereas using new does not involve constructor call",
    "col_7": "Pointer object initialization of a class using new involves constructor call whereas using malloc does not involve constructor call",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 53,
    "col_2": "What is virtual inheritance?",
    "col_3": "C++ technique to avoid multiple copies of the base class into children/derived class",
    "col_4": "C++ technique to avoid multiple inheritances of classes",
    "col_5": "C++ technique to enhance multiple inheritance",
    "col_6": "C++ technique to ensure that a private member of the base class can be accessed somehow",
    "col_7": "C++ technique to avoid multiple copies of the base class into children/derived class",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 54,
    "col_2": "What is the difference between delete and delete[] in C++?",
    "col_3": "delete is used to delete normal objects whereas delete[] is used to pointer objects",
    "col_4": "delete is a keyword whereas delete[] is an identifier",
    "col_5": "delete is used to delete single object whereas delete[] is used to multiple(array/pointer of) objects",
    "col_6": "delete is syntactically correct but delete[] is wrong and hence will give an error if used in any case",
    "col_7": "delete is used to delete single object whereas delete[] is used to multiple(array/pointer of) objects",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 55,
    "col_2": "What is the correct syntax of declaring array of pointers of integers of size 10 in C++?",
    "col_3": "int arr = new int[10];",
    "col_4": "int **arr = new int*[10];",
    "col_5": "int *arr = new int[10];",
    "col_6": "int *arr = new int*[10];",
    "col_7": "int **arr = new int*[10];",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 56,
    "col_2": "Which of the following is correct about new and malloc?i) new is an operator whereas malloc is a functionii) new calls constructor malloc does notiii) new returns required pointer whereas malloc returns void pointer and needs to be typecast",
    "col_3": "i and ii",
    "col_4": "ii and iii",
    "col_5": "i and iii",
    "col_6": "i, ii and iii",
    "col_7": "i, ii and iii",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 57,
    "col_2": "What happens if the following line is executed in C and C++?int *p = malloc(10);",
    "col_3": "Error in both C and C++",
    "col_4": "Warning in both C and C++",
    "col_5": "Error in C++ and successful execution in C",
    "col_6": "Error in C and successful execution in C++",
    "col_7": "Error in C++ and successful execution in C",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 58,
    "col_2": "What happens if the following line is executed in C and C++?const int a;",
    "col_3": "Error in both C and C++",
    "col_4": "Warning in both C and C++",
    "col_5": "Error in C and successful execution in C++",
    "col_6": "Error in C++ and successful execution in C",
    "col_7": "Error in C++ and successful execution in C",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 59,
    "col_2": "Which of the following type is provided by C++ but not C?",
    "col_3": "int",
    "col_4": "bool",
    "col_5": "float",
    "col_6": "double",
    "col_7": "bool",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 60,
    "col_2": "Which of the following feature is not provided by C?",
    "col_3": "Pointers",
    "col_4": "Structures",
    "col_5": "References",
    "col_6": "Functions",
    "col_7": "References",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 61,
    "col_2": "Which of the following is not a fundamental type is not present in C but present in C++?",
    "col_3": "int",
    "col_4": "float",
    "col_5": "bool",
    "col_6": "void",
    "col_7": "bool",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 62,
    "col_2": "What is the size of a boolean variable in C++?",
    "col_3": "1 bit",
    "col_4": "1 byte",
    "col_5": "4 bytes",
    "col_6": "2 bytes",
    "col_7": "1 bit",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 63,
    "col_2": "Which of the following is C++ equivalent for scanf()?",
    "col_3": "cin",
    "col_4": "cout",
    "col_5": "print",
    "col_6": "input",
    "col_7": "cin",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 64,
    "col_2": "Which of the following is C++ equivalent for printf()?",
    "col_3": "cin",
    "col_4": "cout",
    "col_5": "print",
    "col_6": "input",
    "col_7": "cout",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 65,
    "col_2": "Which of the following is the correct difference between cin and scanf()?",
    "col_3": "both are the same",
    "col_4": "cin is a stream object whereas scanf() is a function",
    "col_5": "scanf() is a stream object whereas cin is a function",
    "col_6": "cin is used for printing whereas scanf() is used for reading input",
    "col_7": "cin is a stream object whereas scanf() is a function",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 66,
    "col_2": "Which of the following is an exit-controlled loop?",
    "col_3": "for",
    "col_4": "while",
    "col_5": "do-while",
    "col_6": "all of the mentioned",
    "col_7": "do-while",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 67,
    "col_2": "Which of the following is an entry-controlled loop?",
    "col_3": "for",
    "col_4": "while",
    "col_5": "do-while",
    "col_6": "both while and for",
    "col_7": "both while and for",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 68,
    "col_2": "In which part of the for loop termination condition is checked?for(I;II;III){IV}",
    "col_3": "I",
    "col_4": "II",
    "col_5": "III",
    "col_6": "IV",
    "col_7": "II",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 69,
    "col_2": "What is dynamic binding?",
    "col_3": "The process of linking the actual code with a procedural call during run-time",
    "col_4": "The process of linking the actual code with a procedural call during compile-time",
    "col_5": "The process of linking the actual code with a procedural call at any-time",
    "col_6": "All of the mentioned",
    "col_7": "The process of linking the actual code with a procedural call during run-time",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 70,
    "col_2": "What is static binding?",
    "col_3": "The process of linking the actual code with a procedural call during run-time",
    "col_4": "The process of linking the actual code with a procedural call during compile-time",
    "col_5": "The process of linking the actual code with a procedural call at any-time",
    "col_6": "All of the mentioned",
    "col_7": "The process of linking the actual code with a procedural call during compile-time",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 71,
    "col_2": "What is name mangling in C++?",
    "col_3": "The process of adding more information to a function name so that it can be distinguished from other functions by the compiler",
    "col_4": "The process of making common names for all the function of C++ program for better use",
    "col_5": "The process of changing the names of variable",
    "col_6": "The process of declaring variables of different types",
    "col_7": "The process of adding more information to a function name so that it can be distinguished from other functions by the compiler",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 72,
    "col_2": "Which of the following syntax for declaring a variable of struct STRUCT can be used in both C and C++?",
    "col_3": "struct STRUCT S;",
    "col_4": "STRUCT S;",
    "col_5": "Both struct STRUCT S; and STRUCT S;",
    "col_6": "Both C and C++ have different syntax",
    "col_7": "struct STRUCT S;",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 73,
    "col_2": "What if we define the below structure in C and C++?",
    "col_3": "Error in C but not in C++",
    "col_4": "Error in C++ but not in C",
    "col_5": "No error in both C and C++",
    "col_6": "Error in both C and C++",
    "col_7": "Error in C but not in C++",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 74,
    "col_2": "Which of the following is the scope resolution operator?",
    "col_3": ".",
    "col_4": "*",
    "col_5": "::",
    "col_6": "~",
    "col_7": "::",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 75,
    "col_2": "What is the size of a character literal in C and C++?",
    "col_3": "4 and 1",
    "col_4": "1 and 4",
    "col_5": "1 and 1",
    "col_6": "4 and 4",
    "col_7": "4 and 1",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 76,
    "col_2": "What is the size of a character type in C and C++?",
    "col_3": "4 and 1",
    "col_4": "1 and 4",
    "col_5": "1 and 1",
    "col_6": "4 and 4",
    "col_7": "1 and 1",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 77,
    "col_2": "Which of the following is correct?",
    "col_3": "struct tag is required in both C and C++ while declaring an object of the structure",
    "col_4": "struct is not required in C but required in C++ while declaring an object of the structure",
    "col_5": "struct is not required in C++ but required in C while declaring an object of the structure",
    "col_6": "struct tag is not required in both C and C++ while declaring an object of the structure",
    "col_7": "struct is not required in C++ but required in C while declaring an object of the structure",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 78,
    "col_2": "Which of the following is correct?",
    "col_3": "struct cannot have member function in C but it can in C++",
    "col_4": "struct cannot have member function in C++ but it can in C",
    "col_5": "struct cannot have member function in both C and C++",
    "col_6": "struct can have member function in both C and C++",
    "col_7": "struct cannot have member function in C but it can in C++",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 79,
    "col_2": "Which of the following statement is correct?",
    "col_3": "Structure in C allows Constructor definition",
    "col_4": "Structure in C++ allows Constructor definition",
    "col_5": "Both allow Constructor definition",
    "col_6": "C allows constructor definition while C++ does not",
    "col_7": "Structure in C++ allows Constructor definition",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 80,
    "col_2": "Which of the following is correct about this pointer in C++?",
    "col_3": "this pointer is passed as a hidden argument in all the functions of a class",
    "col_4": "this pointer is passed as a hidden argument in all non-static functions of a class",
    "col_5": "this pointer is passed as a hidden argument in all static functions of a class",
    "col_6": "this pointer is passed as a hidden argument in all static variables of a class",
    "col_7": "this pointer is passed as a hidden argument in all non-static functions of a class",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 81,
    "col_2": "Which of the following operator is used with this pointer to access members of a class?",
    "col_3": ".",
    "col_4": "!",
    "col_5": "->",
    "col_6": "~",
    "col_7": "->",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 82,
    "col_2": "Why this pointer is used?",
    "col_3": "To access the members of a class which have the same name as local variables in that scope",
    "col_4": "To access all the data stored under that class",
    "col_5": "To access objects of other class",
    "col_6": "To access objects of other variables",
    "col_7": "To access the members of a class which have the same name as local variables in that scope",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 83,
    "col_2": "How many types of polymorphism are there?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 2,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 84,
    "col_2": "What is the other name of compile-time polymorphism?",
    "col_3": "Static polymorphism",
    "col_4": "Dynamic polymorphism",
    "col_5": "Executing polymorphism",
    "col_6": "Non-executing polymorphism",
    "col_7": "Static polymorphism",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 85,
    "col_2": "What is the other name of run-time polymorphism?",
    "col_3": "Static polymorphism",
    "col_4": "Dynamic polymorphism",
    "col_5": "Executing polymorphism",
    "col_6": "Non-executing polymorphism",
    "col_7": "Dynamic polymorphism",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 86,
    "col_2": "Which of the following is correct about static polymorphism?",
    "col_3": "In static polymorphism, the conflict between the function call is resolved during the compile time",
    "col_4": "In static polymorphism, the conflict between the function call is resolved during the run time",
    "col_5": "In static polymorphism, the conflict between the function call is never resolved during the execution of a program",
    "col_6": "In static polymorphism, the conflict between the function call is resolved only if it required",
    "col_7": "In static polymorphism, the conflict between the function call is resolved during the compile time",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 87,
    "col_2": "Which of the following is correct about dynamic polymorphism?",
    "col_3": "In dynamic polymorphism, the conflict between the function call is resolved during the compile time",
    "col_4": "In dynamic polymorphism, the conflict between the function call is resolved during the run time",
    "col_5": "In dynamic polymorphism, the conflict between the function call is never resolved during the execution of the program",
    "col_6": "In dynamic polymorphism, the conflict between the function call is resolved at the beginning of the program",
    "col_7": "In dynamic polymorphism, the conflict between the function call is resolved during the run time",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 88,
    "col_2": "Which of the following operator(s) can be used with pointers?i) – onlyii) +, *iii) +, –iv) +, -, *v) /vi) + only",
    "col_3": "i only",
    "col_4": "vi only",
    "col_5": "ii and v",
    "col_6": "iv",
    "col_7": "i only",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 89,
    "col_2": "What is std in C++?",
    "col_3": "std is a standard class in C++",
    "col_4": "std is a standard namespace in C++",
    "col_5": "std is a standard header file in C++",
    "col_6": "std is a standard file reading header in C++",
    "col_7": "std is a standard namespace in C++",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 90,
    "col_2": "Which of the following is correct about static variables?",
    "col_3": "Static functions do not support polymorphism",
    "col_4": "Static data members cannot be accessed by non-static member functions",
    "col_5": "Static data members functions can access only static data members",
    "col_6": "Static data members functions can access both static and non-static data members",
    "col_7": "Static data members functions can access only static data members",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 91,
    "col_2": "Const qualifier can be applied to which of the following?i) Functions inside a classii) Arguments of a functioniii) Static data membersiv) Reference variables",
    "col_3": "i, ii and iii",
    "col_4": "i, ii, iii, and iv",
    "col_5": "ii, iii and iv",
    "col_6": "i only",
    "col_7": "i, ii, iii, and iv",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 92,
    "col_2": "What is the size of wchar_t in C++?",
    "col_3": 2,
    "col_4": 4,
    "col_5": "2 or 4",
    "col_6": "Based on the number of bits in the system",
    "col_7": "Based on the number of bits in the system",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 93,
    "col_2": "Pick the odd one out.",
    "col_3": "array type",
    "col_4": "character type",
    "col_5": "boolean type",
    "col_6": "integer type",
    "col_7": "array type",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 94,
    "col_2": "Which data type is used to represent the absence of parameters?",
    "col_3": "int",
    "col_4": "short",
    "col_5": "void",
    "col_6": "float",
    "col_7": "void",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 95,
    "col_2": "Which type is best suited to represent the logical values?",
    "col_3": "integer",
    "col_4": "boolean",
    "col_5": "character",
    "col_6": "float",
    "col_7": "boolean",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 96,
    "col_2": "Identify the user-defined types from the following?",
    "col_3": "enumeration",
    "col_4": "classes",
    "col_5": "both enumeration and classes",
    "col_6": "int",
    "col_7": "both enumeration and classes",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 97,
    "col_2": "Which of the following statements are true?int f(float)",
    "col_3": "f is a function taking an argument of type int and returning a floating point number",
    "col_4": "f is a function taking an argument of type float and returning an integer",
    "col_5": "f is a function of type float",
    "col_6": "f is a function of type int",
    "col_7": "f is a function taking an argument of type float and returning an integer",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 98,
    "col_2": "The value 132.54 can be represented using which data type?",
    "col_3": "double",
    "col_4": "void",
    "col_5": "int",
    "col_6": "bool",
    "col_7": "double",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 99,
    "col_2": "When a language has the capability to produce new data type mean, it can be called as",
    "col_3": "overloaded",
    "col_4": "extensible",
    "col_5": "encapsulated",
    "col_6": "reprehensible",
    "col_7": "extensible",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 100,
    "col_2": "Pick the odd one out.",
    "col_3": "integer, character, boolean, floating",
    "col_4": "enumeration, classes",
    "col_5": "integer, enum, void",
    "col_6": "arrays, pointer, classes",
    "col_7": "integer, enum, void",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 101,
    "col_2": "Is bool a fundamental data type in C++?",
    "col_3": "Yes",
    "col_4": "No, it is a typedef of unsigned char",
    "col_5": "No, it is an enum of {false, true}",
    "col_6": "No, it is expanded from macros",
    "col_7": "Yes",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 102,
    "col_2": "Find the odd one out.",
    "col_3": "std::vector<int>",
    "col_4": "std::vector<short>",
    "col_5": "std::vector<long>",
    "col_6": "std::vector<bool>",
    "col_7": "std::vector<bool>",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 103,
    "col_2": "What is the value of the bool?  bool is_int(789.54)",
    "col_3": "True",
    "col_4": "False",
    "col_5": 1,
    "col_6": 2,
    "col_7": "False",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 104,
    "col_2": "What happens when a null pointer is converted into bool?",
    "col_3": "an error is flagged",
    "col_4": "bool value evaluates to true",
    "col_5": "bool value evaluates to false",
    "col_6": "the statement is ignored",
    "col_7": "bool value evaluates to false",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 105,
    "col_2": "Which of the following statements are false?",
    "col_3": "bool can have two values and can be used to express logical expressions",
    "col_4": "bool cannot be used as the type of the result of the function",
    "col_5": "bool can be converted into integers implicitly",
    "col_6": "a bool value can be used in arithmetic expressions",
    "col_7": "bool cannot be used as the type of the result of the function",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 106,
    "col_2": "For what values of the expression is an if-statement block not executed?",
    "col_3": "0 and all negative values",
    "col_4": "0 and -1",
    "col_5": 0,
    "col_6": "0, all negative values, all positive values except 1",
    "col_7": 0,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 107,
    "col_2": "Which of the two operators ++ and -- work for the bool data type in C++?",
    "col_3": "None",
    "col_4": "++",
    "col_5": "--",
    "col_6": "++ & --",
    "col_7": "++",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 108,
    "col_2": "How many characters are specified in the ASCII scheme?",
    "col_3": 64,
    "col_4": 128,
    "col_5": 256,
    "col_6": 24,
    "col_7": 128,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 109,
    "col_2": "Given the variables p, q are of char type and r, s, t are of int type. Select the right statement?  (1) t = (r * s) / (r + s);  (2) t = (p * q) / (r + s);",
    "col_3": "1 is true but 2 is false",
    "col_4": "1 is false and 2 is true",
    "col_5": "both 1 and 2 are true",
    "col_6": "both 1 and 2 are false",
    "col_7": "both 1 and 2 are true",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 110,
    "col_2": "Which of the following belongs to the set of character types?",
    "col_3": "char",
    "col_4": "wchar_t",
    "col_5": "only a",
    "col_6": "both wchar_t and char",
    "col_7": "both wchar_t and char",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 111,
    "col_2": "How do we represent a wide character of the form wchar_t?",
    "col_3": "L'a'",
    "col_4": "l'a'",
    "col_5": "L[a]",
    "col_6": "la",
    "col_7": "L'a'",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 112,
    "col_2": "In C++, what is the sign of character data type by default?",
    "col_3": "Signed",
    "col_4": "Unsigned",
    "col_5": "Implementation dependent",
    "col_6": "Unsigned Implementation",
    "col_7": "Implementation dependent",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 113,
    "col_2": "Is the size of character literals different in C and C++?",
    "col_3": "Implementation defined",
    "col_4": "Can't say",
    "col_5": "Yes, they are different",
    "col_6": "No, they are not different",
    "col_7": "Yes, they are different",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 114,
    "col_2": "Suppose in a hypothetical machine, the size of char is 32 bits. What would sizeof(char) return?",
    "col_3": 4,
    "col_4": 1,
    "col_5": "Implementation dependent",
    "col_6": "Machine dependent",
    "col_7": 1,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 115,
    "col_2": "What constant defined in <climits> header returns the number of bits in a char?",
    "col_3": "CHAR_SIZE",
    "col_4": "SIZE_CHAR",
    "col_5": "BIT_CHAR",
    "col_6": "CHAR_BIT",
    "col_7": "CHAR_BIT",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 116,
    "col_2": "The size_t integer type in C++ is?",
    "col_3": "Unsigned integer of at least 64 bits",
    "col_4": "Signed integer of at least 16 bits",
    "col_5": "Unsigned integer of at least 16 bits",
    "col_6": "Signed integer of at least 64 bits",
    "col_7": "Unsigned integer of at least 16 bits",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 117,
    "col_2": "Which of these expressions will return true if the input integer v is a power of two?",
    "col_3": "(v",
    "col_4": "(v + 1)) == 0;",
    "col_5": "(~v & (v – 1)) == 0;",
    "col_6": "(v",
    "col_7": "(v – 1)) == 0;",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 118,
    "col_2": "What is the value of the following 8-bit integer after all statements are executed?  int x = 1;  x = x << 7;  x = x >> 7;",
    "col_3": 1,
    "col_4": -1,
    "col_5": 127,
    "col_6": "Implementation defined",
    "col_7": "Implementation defined",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 119,
    "col_2": "Which of these expressions will make the rightmost set bit zero in an input integer x?",
    "col_3": "x = x",
    "col_4": "(x-1)",
    "col_5": "x = x & (x-1)",
    "col_6": "x = x",
    "col_7": "(x+1)",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 120,
    "col_2": "0946, 786427373824, 'x' and 0X2f are _____ _____ ____ and _____ literals respectively.",
    "col_3": "decimal, character, octal, hexadecimal",
    "col_4": "octal, hexadecimal, character, decimal",
    "col_5": "hexadecimal, octal, decimal, character",
    "col_6": "octal, decimal, character, hexadecimal",
    "col_7": "octal, decimal, character, hexadecimal",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 121,
    "col_2": "Which of the following is not one of the sizes of the floating point types?",
    "col_3": "short float",
    "col_4": "float",
    "col_5": "long double",
    "col_6": "double",
    "col_7": "short float",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 122,
    "col_2": "Which of the following is a valid floating-point literal?",
    "col_3": "f287.333",
    "col_4": "F287.333",
    "col_5": 28700,
    "col_6": "287.3.e2",
    "col_7": 28700,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 123,
    "col_2": "What is the range of the floating point numbers?",
    "col_3": "-3.4E+38 to +3.4E+38",
    "col_4": "-3.4E+38 to +3.4E+34",
    "col_5": "-3.4E+38 to +3.4E+36",
    "col_6": "-3.4E+38 to +3.4E+32",
    "col_7": "-3.4E+38 to +3.4E+38",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 124,
    "col_2": "Which of three sizes of floating point types should be used when extended precision is required?",
    "col_3": "float",
    "col_4": "double",
    "col_5": "long double",
    "col_6": "extended float",
    "col_7": "long double",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 125,
    "col_2": "Which is used to indicate single precision value?",
    "col_3": "F or f",
    "col_4": "L or l",
    "col_5": "Either F or for L or l",
    "col_6": "Neither F or for L or l",
    "col_7": "F or f",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 126,
    "col_2": "Which is correct with respect to the size of the data types?",
    "col_3": "char > int < float",
    "col_4": "int < char > float",
    "col_5": "char < int < float",
    "col_6": "char < int < double",
    "col_7": "char < int < double",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 127,
    "col_2": "The size of an object or a type can be determined using which operator?",
    "col_3": "malloc",
    "col_4": "sizeof",
    "col_5": "malloc",
    "col_6": "calloc",
    "col_7": "sizeof",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 128,
    "col_2": "It is guaranteed that a ____ has at least 8 bits and a ____ has at least 16 bits.",
    "col_3": "int, float",
    "col_4": "char, int",
    "col_5": "bool, char",
    "col_6": "char, short",
    "col_7": "char, short",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 129,
    "col_2": "Implementation dependent aspects about an implementation can be found in ____",
    "col_3": "<implementation>",
    "col_4": "<limits>",
    "col_5": "<limit>",
    "col_6": "<numeric>",
    "col_7": "<limits>",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 130,
    "col_2": "Size of C++ objects are expressed in terms of multiples of the size of a ____ and the size of a char is _______",
    "col_3": "char, 1",
    "col_4": "int, 1",
    "col_5": "float, 8",
    "col_6": "char, 4",
    "col_7": "char, 1",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 131,
    "col_2": "Identify the incorrect option.",
    "col_3": "1 <= sizeof(bool) <= sizeof(long)",
    "col_4": "sizeof(float) <= sizeof(double) <= sizeof(long double)",
    "col_5": "sizeof(char) <= sizeof(long) <=sizeof(wchar_t)",
    "col_6": "sizeof(N) = sizeof(signed N) = sizeof(unsigned N)",
    "col_7": "sizeof(char) <= sizeof(long) <=sizeof(wchar_t)",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 132,
    "col_2": "Which of the following will not return a value?",
    "col_3": null,
    "col_4": "void",
    "col_5": "empty",
    "col_6": "free",
    "col_7": "void",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 133,
    "col_2": "______________ have the return type void.",
    "col_3": "all functions",
    "col_4": "constructors",
    "col_5": "destructors",
    "col_6": "none of the mentioned",
    "col_7": "none of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 134,
    "col_2": "What does the following statement mean? void a;",
    "col_3": "variable a is of type void",
    "col_4": "a is an object of type void",
    "col_5": "declares a variable with value a",
    "col_6": "flags an error",
    "col_7": "flags an error",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 135,
    "col_2": "Choose the incorrect option.",
    "col_3": "void is used when the function does not return a value",
    "col_4": "void is also used when the value of a pointer is null",
    "col_5": "void is used as the base type for pointers to objects of unknown type",
    "col_6": "void is a special fundamental type",
    "col_7": "void is also used when the value of a pointer is null",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 136,
    "col_2": "Identify the incorrect option.",
    "col_3": "enumerators are constants",
    "col_4": "enumerators are user-defined types",
    "col_5": "enumerators are same as macros",
    "col_6": "enumerator values start from 0 by default",
    "col_7": "enumerators are same as macros",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 137,
    "col_2": "In which type do the enumerators are stored by the compiler?",
    "col_3": "string",
    "col_4": "integer",
    "col_5": "float",
    "col_6": "string & float",
    "col_7": "integer",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 138,
    "col_2": "To which of these enumerators can be assigned?",
    "col_3": "integer",
    "col_4": "negative",
    "col_5": "enumerator",
    "col_6": "all of the mentioned",
    "col_7": "all of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 139,
    "col_2": "What will happen when defining the enumerated type?",
    "col_3": "it will not allocate memory",
    "col_4": "it will allocate memory",
    "col_5": "it will not allocate memory to its variables",
    "col_6": "allocate memory to objects",
    "col_7": "it will not allocate memory",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 140,
    "col_2": "Which variable does equals in size with enum variable?",
    "col_3": "int variable",
    "col_4": "float variable",
    "col_5": "string variable",
    "col_6": "float & string variable",
    "col_7": "int variable",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 141,
    "col_2": "Choose the correct option.  extern int i;  int i;",
    "col_3": "both 1 and 2 declare i",
    "col_4": "1 declares the variable i and 2 defines i",
    "col_5": "1 declares and defines i, 2 declares i",
    "col_6": "1 declares i,2 declares and defines i",
    "col_7": "1 declares i,2 declares and defines i",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 142,
    "col_2": "Pick the right option.  Statement 1: A definition is also a declaration.  Statement 2: An identifier can be declared just once.",
    "col_3": "Statement 1 is true, Statement 2 is false",
    "col_4": "Statement 2 is true, Statement 1 is false",
    "col_5": "Both are false",
    "col_6": "Both are true",
    "col_7": "Statement 2 is true, Statement 1 is false",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 143,
    "col_2": "Which of the given statements are false? i. extern int func;  ii. extern int func2(int,int);  iii. int func2(int,int);  iv. extern class foo;",
    "col_3": "iii and iv only",
    "col_4": "ii and iii only",
    "col_5": "only iv",
    "col_6": "ii, iii and iv",
    "col_7": "only iv",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 144,
    "col_2": "Pick the right option.  Statement 1: Global values are not initialized by the stream.  Statement 2: Local values are implicitly initialised to 0.",
    "col_3": "Statement 1 is true, Statement 2 is false",
    "col_4": "Statement 2 is true, Statement 1 is false",
    "col_5": "Both are false",
    "col_6": "Both are true",
    "col_7": "Both are false",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 145,
    "col_2": "What does the following statement mean?  int (*fp)(char*)",
    "col_3": "pointer to a pointer",
    "col_4": "pointer to an array of chars",
    "col_5": "pointer to function taking a char* argument and returns an int",
    "col_6": "function taking a char* argument and returning a pointer to int",
    "col_7": "pointer to function taking a char* argument and returns an int",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 146,
    "col_2": "The operator used for dereferencing or indirection is ____",
    "col_3": "*",
    "col_4": "&",
    "col_5": "->",
    "col_6": "–>>",
    "col_7": "*",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 147,
    "col_2": "Choose the right option.string* x, y;",
    "col_3": "x is a pointer to a string, y is a string",
    "col_4": "y is a pointer to a string, x is a string",
    "col_5": "both x and y are pointers to string types",
    "col_6": "y is a pointer to a string",
    "col_7": "x is a pointer to a string, y is a string",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 148,
    "col_2": "Which one of the following is not a possible state for a pointer.",
    "col_3": "hold the address of the specific object",
    "col_4": "point one past the end of an object",
    "col_5": "zero",
    "col_6": "point to a type",
    "col_7": "point to a type",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 149,
    "col_2": "Which of the following is illegal?",
    "col_3": "int *ip;",
    "col_4": "string s, *sp = 0;",
    "col_5": "int i; double* dp = &i;",
    "col_6": "int *pi = 0;",
    "col_7": "int i; double* dp = &i;",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 150,
    "col_2": "What will happen in the following C++ code snippet?  int a = 100, b = 200;  int *p = &a, *q = &b;  p = q;",
    "col_3": "b is assigned to a",
    "col_4": "p now points to b",
    "col_5": "a is assigned to b",
    "col_6": "q now points to a",
    "col_7": "p now points to b",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 151,
    "col_2": "The correct statement for a function that takes pointer to a float, a pointer to a pointer to a char and returns a pointer to a pointer to a integer is ____________",
    "col_3": "int **fun(float**, char**)",
    "col_4": "int *fun(float*, char*)",
    "col_5": "int **fun(float*, char**)",
    "col_6": "int ***fun(*float, **char)",
    "col_7": "int **fun(float*, char**)",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 152,
    "col_2": "Which of the following correctly declares an array?",
    "col_3": "int array[10];",
    "col_4": "int array;",
    "col_5": "array{10};",
    "col_6": "array array[10];",
    "col_7": "int array[10];",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 153,
    "col_2": "What is the index number of the last element of an array with 9 elements?",
    "col_3": 9,
    "col_4": 8,
    "col_5": 0,
    "col_6": "Programmer-defined",
    "col_7": 8,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 154,
    "col_2": "What is the correct definition of an array?",
    "col_3": "An array is a series of elements of the same type in contiguous memory locations",
    "col_4": "An array is a series of element",
    "col_5": "An array is a series of elements of the same type placed in non-contiguous memory locations",
    "col_6": "An array is an element of the different type",
    "col_7": "An array is a series of elements of the same type in contiguous memory locations",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 155,
    "col_2": "Which of the following accesses the seventh element stored in array?",
    "col_3": "array[6];",
    "col_4": "array[7];",
    "col_5": "array(7);",
    "col_6": "array;",
    "col_7": "array[6];",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 156,
    "col_2": "Which of the following gives the memory address of the first element in array?",
    "col_3": "array[0];",
    "col_4": "array[1];",
    "col_5": "array(2);",
    "col_6": "array;",
    "col_7": "array;",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 157,
    "col_2": "What is the meaning of the following declaration?  int(*p[5])();",
    "col_3": "p is pointer to function",
    "col_4": "p is array of pointer to function",
    "col_5": "p is pointer to such function which return type is the array",
    "col_6": "p is pointer to array of function",
    "col_7": "p is array of pointer to function",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 158,
    "col_2": "What is size of generic pointer in C++ (in 32-bit platform)?",
    "col_3": 2,
    "col_4": 4,
    "col_5": 8,
    "col_6": 0,
    "col_7": 4,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 159,
    "col_2": "The constants are also called as _____________",
    "col_3": "const",
    "col_4": "preprocessor",
    "col_5": "literals",
    "col_6": "variables",
    "col_7": "literals",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 160,
    "col_2": "What are the parts of the literal constants?",
    "col_3": "integer numerals",
    "col_4": "floating-point numerals",
    "col_5": "strings and boolean values",
    "col_6": "all of the mentioned",
    "col_7": "all of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 161,
    "col_2": "How are the constants declared?",
    "col_3": "const keyword",
    "col_4": "#define preprocessor",
    "col_5": "both const keyword and #define preprocessor",
    "col_6": "$define",
    "col_7": "both const keyword and #define preprocessor",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 162,
    "col_2": "Which of the following statement is not true about preprocessor directives?",
    "col_3": "These are lines read and processed by the preprocessor",
    "col_4": "They do not produce any code by themselves",
    "col_5": "These must be written on their own line",
    "col_6": "They end with a semicolon",
    "col_7": "They end with a semicolon",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 163,
    "col_2": "Regarding the following statement which of the statements is true?  const int a = 100;",
    "col_3": "Declares a variable a with 100 as its initial value",
    "col_4": "Declares a construction a with 100 as its initial value",
    "col_5": "Declares a constant a whose value will be 100",
    "col_6": "Constructs an integer type variable with an as identifier and 100 as the value",
    "col_7": "Declares a constant a whose value will be 100",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 164,
    "col_2": "The difference between x and 'x' is?",
    "col_3": "The first one refers to a variable whose identifier is x and the second one refers to the character constant x",
    "col_4": "The first one is a character constant x and the second one is the string literal x",
    "col_5": "Both are same",
    "col_6": "Both are string literal",
    "col_7": "The first one refers to a variable whose identifier is x and the second one refers to the character constant x",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 165,
    "col_2": "How to declare a wide character in the string literal?",
    "col_3": "L prefix",
    "col_4": "l prefix",
    "col_5": "W prefix",
    "col_6": "Z prefix",
    "col_7": "L prefix",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 166,
    "col_2": "Which value can we not assign to reference?",
    "col_3": "integer",
    "col_4": "floating",
    "col_5": "unsigned",
    "col_6": null,
    "col_7": null,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 167,
    "col_2": "Identify the incorrect statement.",
    "col_3": "Reference is the alternate name of the object",
    "col_4": "A reference value once defined can be reassigned",
    "col_5": "A reference value once defined cannot be reassigned",
    "col_6": "Reference is the alternate name of the variable",
    "col_7": "A reference value once defined can be reassigned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 168,
    "col_2": "Which reference modifier is used to define the reference variable?",
    "col_3": "&",
    "col_4": "$",
    "col_5": "#",
    "col_6": "@",
    "col_7": "&",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 169,
    "col_2": "What does a reference provide?",
    "col_3": "Alternate name for the class",
    "col_4": "Alternate name for the variable",
    "col_5": "Alternate name for the pointer",
    "col_6": "Alternate name for the object",
    "col_7": "Alternate name for the variable",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 170,
    "col_2": "Identify the correct sentence regarding inequality between reference and pointer.",
    "col_3": "we can not create the array of reference",
    "col_4": "we can create the Array of reference",
    "col_5": "we can use reference to reference",
    "col_6": "we can use variable",
    "col_7": "we can not create the array of reference",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 171,
    "col_2": "What are the references in C++?",
    "col_3": "An alternative name for already existing variables",
    "col_4": "A pointer to a variable",
    "col_5": "A new type of variables",
    "col_6": "A new type of constant variable",
    "col_7": "An alternative name for already existing variables",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 172,
    "col_2": "What is the difference between references and pointers?",
    "col_3": "References are an alias for a variable whereas pointer stores the address of a variable",
    "col_4": "References and pointers are similar",
    "col_5": "References stores address of variables whereas pointer points to variables",
    "col_6": "Pointers are an alias for a variable whereas references stores the address of a variable",
    "col_7": "References are an alias for a variable whereas pointer stores the address of a variable",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 173,
    "col_2": "Pick the correct statement about references in C++.",
    "col_3": "References stores the address of variables",
    "col_4": "References and variables both have the same address",
    "col_5": "References use dereferencing operator(*) to access the value of variable its referencing",
    "col_6": "References were also available in C",
    "col_7": "References and variables both have the same address",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 174,
    "col_2": "Pick the correct statement about references.",
    "col_3": "References can be assigned value NULL",
    "col_4": "References once assigned cannot be changed to refer another variable",
    "col_5": "Reference should not be initialized when created",
    "col_6": "Reference is the same as pointers",
    "col_7": "References once assigned cannot be changed to refer another variable",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 175,
    "col_2": "Which of the following is incorrect?",
    "col_3": "References cannot be NULL",
    "col_4": "A reference must be initialized when declared",
    "col_5": "Once a reference is declared, it cannot be modified later to reference another object i.e. it cannot be reset",
    "col_6": "References cannot refer to a constant value",
    "col_7": "References cannot refer to a constant value",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 176,
    "col_2": "Which of the following function must use reference.",
    "col_3": "Assignment operator function",
    "col_4": "Copy Constructor",
    "col_5": "Destructor",
    "col_6": "Parameterized constructor",
    "col_7": "Copy Constructor",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 177,
    "col_2": "How a reference is different from a pointer?",
    "col_3": "A reference cannot be null",
    "col_4": "A reference once established cannot be changed",
    "col_5": "The reference doesn't need an explicit dereferencing mechanism",
    "col_6": "All of the mentioned",
    "col_7": "All of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 178,
    "col_2": "Which of the following statement(s) is/are correct?",
    "col_3": "* operator is used to declare a reference",
    "col_4": "A reference variable defined to refer a particular variable can refer to any other variable also",
    "col_5": "References must always be initialized inside classes",
    "col_6": "A variable can have more than one references",
    "col_7": "A variable can have more than one references",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 179,
    "col_2": "The void pointer can point to which type of objects?",
    "col_3": "int",
    "col_4": "float",
    "col_5": "double",
    "col_6": "all of the mentioned",
    "col_7": "all of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 180,
    "col_2": "When does the void pointer can be dereferenced?",
    "col_3": "when it doesn't point to any value",
    "col_4": "when it cast to another type of object",
    "col_5": "using delete keyword",
    "col_6": "using shift keyword",
    "col_7": "when it cast to another type of object",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 181,
    "col_2": "The pointer can point to any variable that is not declared with which of these?",
    "col_3": "const",
    "col_4": "volatile",
    "col_5": "both const & volatile",
    "col_6": "static",
    "col_7": "both const & volatile",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 182,
    "col_2": "A void pointer cannot point to which of these?",
    "col_3": "methods in c++",
    "col_4": "class member in c++",
    "col_5": "methods & class member in c++",
    "col_6": "none of the mentioned",
    "col_7": "none of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 183,
    "col_2": "What we can't do on a void pointer?",
    "col_3": "pointer arithmetic",
    "col_4": "pointer functions",
    "col_5": "pointer objects",
    "col_6": "pointer functions & objects",
    "col_7": "pointer arithmetic",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 184,
    "col_2": "The data elements in the structure are also known as what?",
    "col_3": "objects",
    "col_4": "members",
    "col_5": "data",
    "col_6": "objects & data",
    "col_7": "members",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 185,
    "col_2": "What will be used when terminating a structure?",
    "col_3": ":",
    "col_4": "}",
    "col_5": ";",
    "col_6": ";;",
    "col_7": ";",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 186,
    "col_2": "What will happen when the structure is declared?",
    "col_3": "it will not allocate any memory",
    "col_4": "it will allocate the memory",
    "col_5": "it will be declared and initialized",
    "col_6": "it will be declared",
    "col_7": "it will not allocate any memory",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 187,
    "col_2": "The declaration of the structure is also called as?",
    "col_3": "structure creator",
    "col_4": "structure signifier",
    "col_5": "structure specifier",
    "col_6": "structure creator & signifier",
    "col_7": "structure specifier",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 188,
    "col_2": "Which of the following is a properly defined structure?",
    "col_3": "struct {int a;}",
    "col_4": "struct a_struct {int a;}",
    "col_5": "struct a_struct int a;",
    "col_6": "struct a_struct {int a;};",
    "col_7": "struct a_struct {int a;};",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 189,
    "col_2": "Which of the following accesses a variable in structure *b?",
    "col_3": "b->var;",
    "col_4": "b.var;",
    "col_5": "b-var;",
    "col_6": "b>var;",
    "col_7": "b->var;",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 190,
    "col_2": "Which function is used to check whether a character is an alphabet?",
    "col_3": "isalpha()",
    "col_4": "isalnum()",
    "col_5": "isdigit()",
    "col_6": "isblank()",
    "col_7": "isalpha()",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 191,
    "col_2": "Which function is used to check whether a character is an alphabet or number?",
    "col_3": "isalpha()",
    "col_4": "isalnum()",
    "col_5": "isdigit()",
    "col_6": "isblank()",
    "col_7": "isalnum()",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 192,
    "col_2": "Which function is used to check whether a character is a number?",
    "col_3": "isalpha()",
    "col_4": "isalnum()",
    "col_5": "isdigit()",
    "col_6": "isblank()",
    "col_7": "isdigit()",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 193,
    "col_2": "Which function is used to check whether a character is a tab or space?",
    "col_3": "isalpha()",
    "col_4": "isalnum()",
    "col_5": "isdigit()",
    "col_6": "isblank()",
    "col_7": "isblank()",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 194,
    "col_2": "Which function is used to check whether a character is tab or a control code?",
    "col_3": "isspace()",
    "col_4": "isalnum()",
    "col_5": "iscntrl()",
    "col_6": "isblank()",
    "col_7": "iscntrl()",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 195,
    "col_2": "Which function is used to check whether a character is printable on console?",
    "col_3": "isxdigit()",
    "col_4": "isprint()",
    "col_5": "iscntrl()",
    "col_6": "ispunct()",
    "col_7": "isprint()",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 196,
    "col_2": "Which function is used to check whether a character is hexadecimal?",
    "col_3": "isxdigit()",
    "col_4": "isprint()",
    "col_5": "iscntrl()",
    "col_6": "ispunct()",
    "col_7": "isxdigit()",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 197,
    "col_2": "Which function is used to check whether a character is punctuation mark?",
    "col_3": "isxdigit()",
    "col_4": "isprint()",
    "col_5": "iscntrl()",
    "col_6": "ispunct()",
    "col_7": "ispunct()",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 198,
    "col_2": "Which operator is having the right to left associativity in the following?",
    "col_3": "Array subscripting",
    "col_4": "Function call",
    "col_5": "Addition and subtraction",
    "col_6": "Type cast",
    "col_7": "Type cast",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 199,
    "col_2": "Which operator is having the highest precedence?",
    "col_3": "postfix",
    "col_4": "unary",
    "col_5": "shift",
    "col_6": "equality",
    "col_7": "postfix",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 200,
    "col_2": "What is this operator called ?:?",
    "col_3": "conditional",
    "col_4": "relational",
    "col_5": "casting operator",
    "col_6": "unrelational",
    "col_7": "conditional",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 201,
    "col_2": "What is the use of dynamic_cast operator?",
    "col_3": "it converts virtual base class to derived class",
    "col_4": "it converts the virtual base object to derived objects",
    "col_5": "it will convert the operator based on precedence",
    "col_6": "it converts the virtual base object to derived class",
    "col_7": "it converts virtual base class to derived class",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 202,
    "col_2": "How are many sequences of statements present in c++?",
    "col_3": 4,
    "col_4": 3,
    "col_5": 5,
    "col_6": 6,
    "col_7": 5,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 203,
    "col_2": "The if..else statement can be replaced by which operator?",
    "col_3": "Bitwise operator",
    "col_4": "Conditional operator",
    "col_5": "Multiplicative operator",
    "col_6": "Addition operator",
    "col_7": "Conditional operator",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 204,
    "col_2": "The switch statement is also called as?",
    "col_3": "choosing structure",
    "col_4": "selective structure",
    "col_5": "certain structure",
    "col_6": "bitwise structure",
    "col_7": "selective structure",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 205,
    "col_2": "The destination statement for the goto label is identified by what label?",
    "col_3": "$",
    "col_4": "@",
    "col_5": "*",
    "col_6": ":",
    "col_7": ":",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 206,
    "col_2": "How many types of loops are there in C++?",
    "col_3": 4,
    "col_4": 2,
    "col_5": 3,
    "col_6": 1,
    "col_7": 4,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 207,
    "col_2": "Which looping process is best used when the number of iterations is known?",
    "col_3": "for",
    "col_4": "while",
    "col_5": "do-while",
    "col_6": "all looping processes require that the iterations be known",
    "col_7": "for",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 208,
    "col_2": "How many types of comments are there in c++?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 2,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 209,
    "col_2": "What is a comment in c++?",
    "col_3": "comments are parts of the source code disregarded by the compiler",
    "col_4": "comments are executed by the compiler to find the meaning of the comment",
    "col_5": "comments are executable",
    "col_6": "comments are executed by the compiler",
    "col_7": "comments are parts of the source code disregarded by the compiler",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 210,
    "col_2": "What type of comments does c++ support?",
    "col_3": "single line",
    "col_4": "multiline",
    "col_5": "single line and multi-line",
    "col_6": "reusable line",
    "col_7": "single line and multi-line",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 211,
    "col_2": "What is used to write multi line comment in c++?",
    "col_3": "/* …. */",
    "col_4": "/$ …. $/",
    "col_5": "//",
    "col_6": "/$ …. */",
    "col_7": "/* …. */",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 212,
    "col_2": "What is the use of the indentation in c++?",
    "col_3": "distinguishes between comments and code",
    "col_4": "r distinguishes between comments and outer data",
    "col_5": "distinguishes between comments and outer data",
    "col_6": "r distinguishes between comments and inner data",
    "col_7": "distinguishes between comments and code",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 213,
    "col_2": "Where does the execution of the program starts?",
    "col_3": "user-defined function",
    "col_4": "main function",
    "col_5": "void function",
    "col_6": "else function",
    "col_7": "main function",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 214,
    "col_2": "What are mandatory parts in the function declaration?",
    "col_3": "return type, function name",
    "col_4": "return type, function name, parameters",
    "col_5": "parameters, function name",
    "col_6": "parameters, variables",
    "col_7": "return type, function name",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 215,
    "col_2": "which of the following is used to terminate the function declaration?",
    "col_3": ":",
    "col_4": ")",
    "col_5": ";",
    "col_6": "]",
    "col_7": ";",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 216,
    "col_2": "How many can max number of arguments present in function in the c99 compiler?",
    "col_3": 99,
    "col_4": 90,
    "col_5": 102,
    "col_6": 127,
    "col_7": 127,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 217,
    "col_2": "Which is more effective while calling the functions?",
    "col_3": "call by value",
    "col_4": "call by reference",
    "col_5": "call by pointer",
    "col_6": "call by object",
    "col_7": "call by reference",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 218,
    "col_2": "What is the scope of the variable declared in the user defined function?",
    "col_3": "whole program",
    "col_4": "only inside the {} block",
    "col_5": "the main function",
    "col_6": "header section",
    "col_7": "only inside the {} block",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 219,
    "col_2": "How many minimum number of functions should be present in a C++ program for its execution?",
    "col_3": 0,
    "col_4": 1,
    "col_5": 2,
    "col_6": 3,
    "col_7": 1,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 220,
    "col_2": "Which of the following is the default return value of functions in C++?",
    "col_3": "int",
    "col_4": "char",
    "col_5": "float",
    "col_6": "void",
    "col_7": "int",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 221,
    "col_2": "What happens to a function defined inside a class without any complex operations (like looping, a large number of lines, etc)?",
    "col_3": "It becomes a virtual function of the class",
    "col_4": "It becomes a default calling function of the class",
    "col_5": "It becomes an inline function of the class",
    "col_6": "The program gives an error",
    "col_7": "It becomes an inline function of the class",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 222,
    "col_2": "What is an inline function?",
    "col_3": "A function that is expanded at each call during execution",
    "col_4": "A function that is called during compile time",
    "col_5": "A function that is not checked for syntax errors",
    "col_6": "A function that is not checked for semantic analysis",
    "col_7": "A function that is expanded at each call during execution",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 223,
    "col_2": "An inline function is expanded during ______________",
    "col_3": "compile-time",
    "col_4": "run-time",
    "col_5": "never expanded",
    "col_6": "end of the program",
    "col_7": "run-time",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 224,
    "col_2": "In which of the following cases inline functions may not word? i) If the function has static variables.  ii) If the function has global and register variables.  iii) If the function contains loops  iv) If the function is recursive",
    "col_3": "i, iv",
    "col_4": "iii, iv",
    "col_5": "ii, iii, iv",
    "col_6": "i, iii, iv",
    "col_7": "i, iii, iv",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 225,
    "col_2": "When we define the default values for a function?",
    "col_3": "When a function is defined",
    "col_4": "When a function is declared",
    "col_5": "When the scope of the function is over",
    "col_6": "When a function is called",
    "col_7": "When a function is declared",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 226,
    "col_2": "Where should default parameters appear in a function prototype?",
    "col_3": "To the rightmost side of the parameter list",
    "col_4": "To the leftmost side of the parameter list",
    "col_5": "Anywhere inside the parameter list",
    "col_6": "Middle of the parameter list",
    "col_7": "To the rightmost side of the parameter list",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 227,
    "col_2": "If an argument from the parameter list of a function is defined constant then _______________",
    "col_3": "It can be modified inside the function",
    "col_4": "It cannot be modified inside the function",
    "col_5": "Error occurs",
    "col_6": "Segmentation fault",
    "col_7": "It cannot be modified inside the function",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 228,
    "col_2": "Which of the following feature is used in function overloading and function with default argument?",
    "col_3": "Encapsulation",
    "col_4": "Polymorphism",
    "col_5": "Abstraction",
    "col_6": "Modularity",
    "col_7": "Abstraction",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 229,
    "col_2": "From which function the execution of a C++ program starts?",
    "col_3": "start() function",
    "col_4": "main() function",
    "col_5": "new() function",
    "col_6": "end() function",
    "col_7": "main() function",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 230,
    "col_2": "Which of the following is important in a function?",
    "col_3": "Return type",
    "col_4": "Function name",
    "col_5": "Both return type and function name",
    "col_6": "The return type, function name and parameter list",
    "col_7": "Both return type and function name",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 231,
    "col_2": "How many ways of passing a parameter are there in c++?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 3,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 232,
    "col_2": "Which is used to keep the call by reference value as intact?",
    "col_3": "static",
    "col_4": "const",
    "col_5": "absolute",
    "col_6": "virtual",
    "col_7": "const",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 233,
    "col_2": "By default how the value are passed in c++?",
    "col_3": "call by value",
    "col_4": "call by reference",
    "col_5": "call by pointer",
    "col_6": "call by object",
    "col_7": "call by value",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 234,
    "col_2": "What will happen when we use void in argument passing?",
    "col_3": "It will not return value to its caller",
    "col_4": "It will return value to its caller",
    "col_5": "Maybe or may not be return any value to its caller",
    "col_6": "It will return value with help of object",
    "col_7": "It will not return value to its caller",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 235,
    "col_2": "How many types of returning values are present in c++?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 3,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 236,
    "col_2": "What will you use if you are not intended to get a return value?",
    "col_3": "static",
    "col_4": "const",
    "col_5": "volatile",
    "col_6": "void",
    "col_7": "void",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 237,
    "col_2": "Where does the return statement returns the execution of the program?",
    "col_3": "main function",
    "col_4": "caller function",
    "col_5": "same function",
    "col_6": "block function",
    "col_7": "caller function",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 238,
    "col_2": "When will we use the function overloading?",
    "col_3": "same function name but different number of arguments",
    "col_4": "different function name but same number of arguments",
    "col_5": "same function name but same number of arguments",
    "col_6": "different function name but different number of arguments",
    "col_7": "same function name but different number of arguments",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 239,
    "col_2": "Which of the following permits function overloading on c++?",
    "col_3": "type",
    "col_4": "number of arguments",
    "col_5": "type & number of arguments",
    "col_6": "number of objects",
    "col_7": "type & number of arguments",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 240,
    "col_2": "In which of the following we cannot overload the function?",
    "col_3": "return function",
    "col_4": "caller",
    "col_5": "called function",
    "col_6": "main function",
    "col_7": "return function",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 241,
    "col_2": "Function overloading is also similar to which of the following?",
    "col_3": "operator overloading",
    "col_4": "constructor overloading",
    "col_5": "destructor overloading",
    "col_6": "function overloading",
    "col_7": "constructor overloading",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 242,
    "col_2": "Overloaded functions are ________________",
    "col_3": "Very long functions that can hardly run",
    "col_4": "One function containing another one or more functions inside it",
    "col_5": "Two or more functions with the same name but different number of parameters or type",
    "col_6": "Very long functions",
    "col_7": "Two or more functions with the same name but different number of parameters or type",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 243,
    "col_2": "What will happen while using pass by reference?",
    "col_3": "The values of those variables are passed to the function so that it can manipulate them",
    "col_4": "The location of variable in memory is passed to the function so that it can use the same memory area for its processing",
    "col_5": "The function declaration should contain ampersand (& in its type declaration)",
    "col_6": "The function declaration should contain $",
    "col_7": "The location of variable in memory is passed to the function so that it can use the same memory area for its processing",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 244,
    "col_2": "What should be passed in parameters when function does not require any parameters?",
    "col_3": "void",
    "col_4": "blank space",
    "col_5": "both void & blank space",
    "col_6": "tab space",
    "col_7": "blank space",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 245,
    "col_2": "What are the advantages of passing arguments by reference?",
    "col_3": "Changes to parameter values within the function also affect the original arguments",
    "col_4": "There is need to copy parameter values (i.e. less memory used)",
    "col_5": "There is no need to call constructors for parameters (i.e. faster)",
    "col_6": "All of the mentioned",
    "col_7": "All of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 246,
    "col_2": "If the user did not supply the value, what value will it take?",
    "col_3": "default value",
    "col_4": "rise an error",
    "col_5": "both default value & rise an error",
    "col_6": "error",
    "col_7": "default value",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 247,
    "col_2": "Where can the default parameter be placed by the user?",
    "col_3": "leftmost",
    "col_4": "rightmost",
    "col_5": "both leftmost & rightmost",
    "col_6": "topmost",
    "col_7": "rightmost",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 248,
    "col_2": "Which value will it take when both user and default values are given?",
    "col_3": "user value",
    "col_4": "default value",
    "col_5": "custom value",
    "col_6": "defined value",
    "col_7": "user value",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 249,
    "col_2": "What we can't place followed by the non-default arguments?",
    "col_3": "trailing arguments",
    "col_4": "default arguments",
    "col_5": "both trailing & default arguments",
    "col_6": "leading arguments",
    "col_7": "default arguments",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 250,
    "col_2": "If we start our function call with default arguments means, what will be proceeding arguments?",
    "col_3": "user argument",
    "col_4": "empty arguments",
    "col_5": "default arguments",
    "col_6": "user & empty arguments",
    "col_7": "default arguments",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 251,
    "col_2": "What is the default return type of a function?",
    "col_3": "int",
    "col_4": "void",
    "col_5": "float",
    "col_6": "char",
    "col_7": "void",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 252,
    "col_2": "Which header file is used to pass unknown number of arguments to function?",
    "col_3": "stdlib.h",
    "col_4": "string.h",
    "col_5": "stdarg.h",
    "col_6": "stdio.h",
    "col_7": "stdarg.h",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 253,
    "col_2": "How can you access the arguments that are manipulated in the function?",
    "col_3": "va_list",
    "col_4": "arg_list",
    "col_5": "both va_list & arg_list",
    "col_6": "vg_list",
    "col_7": "va_list",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 254,
    "col_2": "What is the maximum number of arguments or parameters that can be present in one function call?",
    "col_3": 64,
    "col_4": 256,
    "col_5": 255,
    "col_6": 16,
    "col_7": 256,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 255,
    "col_2": "What will initialize the list of arguments in stdarg.h header file?",
    "col_3": "va_list",
    "col_4": "va_start",
    "col_5": "va_arg",
    "col_6": "vg_arg",
    "col_7": "va_start",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 256,
    "col_2": "To which does the function pointer point to?",
    "col_3": "variable",
    "col_4": "constants",
    "col_5": "function",
    "col_6": "absolute variables",
    "col_7": "function",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 257,
    "col_2": "What will we not do with function pointers?",
    "col_3": "allocation of memory",
    "col_4": "deallocation of memory",
    "col_5": "both allocation & deallocation of memory",
    "col_6": "finds memory status",
    "col_7": "both allocation & deallocation of memory",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 258,
    "col_2": "What is the default calling convention for a compiler in c++?",
    "col_3": "_cdecl",
    "col_4": "_stdcall",
    "col_5": "_pascal",
    "col_6": "_fastcall",
    "col_7": "_cdecl",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 259,
    "col_2": "What is the mandatory part to present in function pointers?",
    "col_3": "&",
    "col_4": "return values",
    "col_5": "data types",
    "col_6": "$",
    "col_7": "data types",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 260,
    "col_2": "which of the following can be passed in function pointers?",
    "col_3": "variables",
    "col_4": "data types",
    "col_5": "functions",
    "col_6": "objects",
    "col_7": "functions",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 261,
    "col_2": "What is the meaning of the following declaration?  int(*ptr[5])();",
    "col_3": "ptr is pointer to function",
    "col_4": "ptr is array of pointer to function",
    "col_5": "ptr is pointer to such function which return type is array",
    "col_6": "ptr is pointer to array of function",
    "col_7": "ptr is array of pointer to function",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 262,
    "col_2": "which keyword is used to define the macros in c++?",
    "col_3": "macro",
    "col_4": "define",
    "col_5": "#define",
    "col_6": "#macro",
    "col_7": "#define",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 263,
    "col_2": "Which symbol is used to declare the preprocessor directives?",
    "col_3": "#",
    "col_4": "$",
    "col_5": "*",
    "col_6": "",
    "col_7": "#",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 264,
    "col_2": "How many types of macros are there in c++?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 2,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 265,
    "col_2": "What is the mandatory preprocessor directive for c++?",
    "col_3": "#define <iostream>",
    "col_4": "#include <iostream>",
    "col_5": "#undef <iostream>",
    "col_6": "#macro <iostream>",
    "col_7": "#include <iostream>",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 266,
    "col_2": "What is the other name of the macro?",
    "col_3": "scripted directive",
    "col_4": "executed directive",
    "col_5": "link directive",
    "col_6": "executed & link directive",
    "col_7": "scripted directive",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 267,
    "col_2": "which of the following is used to implement the c++ interfaces?",
    "col_3": "absolute variables",
    "col_4": "abstract classes",
    "col_5": "constant variables",
    "col_6": "default variables",
    "col_7": "abstract classes",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 268,
    "col_2": "What is the ability to group some lines of code that can be included?in the program?",
    "col_3": "specific task",
    "col_4": "program control",
    "col_5": "modularization",
    "col_6": "macros",
    "col_7": "modularization",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 269,
    "col_2": "How many types do functions fall depends on modularization?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 2,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 270,
    "col_2": "How many types of modularization are there in c++?",
    "col_3": 4,
    "col_4": 3,
    "col_5": 1,
    "col_6": 2,
    "col_7": 2,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 271,
    "col_2": "What does the client module import?",
    "col_3": "macro",
    "col_4": "records",
    "col_5": "interface",
    "col_6": "instance",
    "col_7": "interface",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 272,
    "col_2": "Identify the correct statement.",
    "col_3": "c++ does not have built-in interfaces",
    "col_4": "c++ does have built-in interfaces",
    "col_5": "c++ have no concept of interfaces",
    "col_6": "c++ does have built-in interfaces & classes",
    "col_7": "c++ does not have built-in interfaces",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 273,
    "col_2": "What is similar to the interface in c++?",
    "col_3": "methods",
    "col_4": "instance of a class",
    "col_5": "pure abstract class",
    "col_6": "methods & instance of a class",
    "col_7": "pure abstract class",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 274,
    "col_2": "Which of the following implements the module in the program?",
    "col_3": "macro",
    "col_4": "header files",
    "col_5": "macro & header files",
    "col_6": "interfaces",
    "col_7": "header files",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 275,
    "col_2": "Which operator is used to signify the namespace?",
    "col_3": "conditional operator",
    "col_4": "ternary operator",
    "col_5": "scope operator",
    "col_6": "bitwise operator",
    "col_7": "scope operator",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 276,
    "col_2": "Identify the correct statement.",
    "col_3": "Namespace is used to group class, objects and functions",
    "col_4": "Namespace is used to mark the beginning of the program",
    "col_5": "A namespace is used to separate the class, objects",
    "col_6": "Namespace is used to mark the beginning & end of the program",
    "col_7": "Namespace is used to group class, objects and functions",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 277,
    "col_2": "What is the use of Namespace?",
    "col_3": "To encapsulate the data",
    "col_4": "To structure a program into logical units",
    "col_5": "Encapsulate the data & structure a program into logical units",
    "col_6": "It is used to mark the beginning of the program",
    "col_7": "To structure a program into logical units",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 278,
    "col_2": "What is the general syntax for accessing the namespace variable?",
    "col_3": "namespace::operator",
    "col_4": "namespace,operator",
    "col_5": "namespace#operator",
    "col_6": "namespace$operator",
    "col_7": "namespace::operator",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 279,
    "col_2": "Which keyword is used to access the variable in the namespace?",
    "col_3": "using",
    "col_4": "dynamic",
    "col_5": "const",
    "col_6": "static",
    "col_7": "using",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 280,
    "col_2": "Pick the incorrect statement for namespaces in C++.",
    "col_3": "Namespace declarations are always global scope",
    "col_4": "Keyword namespace is used at the starting of a namespace definition",
    "col_5": "Namespace has access specifiers like private or public",
    "col_6": "Namespace definitions can be nested",
    "col_7": "Namespace has access specifiers like private or public",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 281,
    "col_2": "Which operator is used for accessing a member of namespace?",
    "col_3": ":",
    "col_4": "::",
    "col_5": "->",
    "col_6": ".",
    "col_7": "::",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 282,
    "col_2": "What is the correct syntax of defining a namespace?",
    "col_3": "namespace name{}",
    "col_4": "Namespace name{};",
    "col_5": "namespace name{};",
    "col_6": "typedef namespace name{} NAME",
    "col_7": "namespace name{}",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 283,
    "col_2": "To where does the program control transfers when the exception is arisen?",
    "col_3": "catch",
    "col_4": "handlers",
    "col_5": "throw",
    "col_6": "try",
    "col_7": "handlers",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 284,
    "col_2": "Which keyword is used to check exception in the block of code?",
    "col_3": "catch",
    "col_4": "throw",
    "col_5": "try",
    "col_6": "handlers",
    "col_7": "try",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 285,
    "col_2": "What will happen when the exception is not caught in the program?",
    "col_3": "error",
    "col_4": "program will execute",
    "col_5": "block of that code will not execute",
    "col_6": "program will execute & displays wrong output",
    "col_7": "error",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 286,
    "col_2": "What will happen when the handler is not found for an exception?",
    "col_3": "calls the standard library function terminate()",
    "col_4": "raise an error",
    "col_5": "executes the remaining block",
    "col_6": "raise an error and executes the remaining block",
    "col_7": "calls the standard library function terminate()",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 287,
    "col_2": "How many types of linkages are there in C++?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 3,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 288,
    "col_2": "To use internal linkage we have to use which keyword?",
    "col_3": "static",
    "col_4": "extern",
    "col_5": "static or extern",
    "col_6": "public",
    "col_7": "static",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 289,
    "col_2": "Which one is used to refer to program elements in any translation units?",
    "col_3": "internal linkage",
    "col_4": "external linkage",
    "col_5": "no linkage",
    "col_6": "internal & external linkage",
    "col_7": "external linkage",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 290,
    "col_2": "What is the default type of linkage that is available for identifiers?",
    "col_3": "internal",
    "col_4": "external",
    "col_5": "no linkage",
    "col_6": "single linkage",
    "col_7": "external",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 291,
    "col_2": "To use external linkage we have to use which keyword?",
    "col_3": "static",
    "col_4": "extern",
    "col_5": "const",
    "col_6": "argc",
    "col_7": "extern",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 292,
    "col_2": "Which is used to use a function from one source file to another?",
    "col_3": "code",
    "col_4": "declaration",
    "col_5": "prototype",
    "col_6": "variable",
    "col_7": "prototype",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 293,
    "col_2": "What is the use of no linkage?",
    "col_3": "make the entity visible to other programs",
    "col_4": "make the entity visible to other blocks in the same program",
    "col_5": "make the entity visible only to that block",
    "col_6": "make the entity invisible",
    "col_7": "make the entity visible only to that block",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 294,
    "col_2": "What is the user-defined header file extension in c++?",
    "col_3": "cpp",
    "col_4": "h",
    "col_5": "hf",
    "col_6": "hg",
    "col_7": "h",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 295,
    "col_2": "Which of the following keyword is used to declare the header file?",
    "col_3": "include",
    "col_4": "exclude",
    "col_5": "string",
    "col_6": "namespace",
    "col_7": "include",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 296,
    "col_2": "Identify the incorrect statement.",
    "col_3": "iostream is a standard header and iostream.h is a non-standard header",
    "col_4": "iostream is a non-standard header and iostream.h is a non-standard header",
    "col_5": "iostream is a standard header and iostream.h is a standard header",
    "col_6": "iostream is a non-standard header",
    "col_7": "iostream is a standard header and iostream.h is a non-standard header",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 297,
    "col_2": "What does a default header file contain?",
    "col_3": "prototype",
    "col_4": "implementation",
    "col_5": "declarations",
    "col_6": "pointing",
    "col_7": "declarations",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 298,
    "col_2": "setprecision requires which of the following header file?",
    "col_3": "stdlib.h",
    "col_4": "iomanip.h",
    "col_5": "console.h",
    "col_6": "conio.h",
    "col_7": "iomanip.h",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 299,
    "col_2": "Which of the following header file does not exist?",
    "col_3": "<iostream>",
    "col_4": "<string>",
    "col_5": "<sstring>",
    "col_6": "<sstream>",
    "col_7": "<sstring>",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 300,
    "col_2": "Which of the header file must be included to use stringstream?",
    "col_3": "<iostream>",
    "col_4": "<string>",
    "col_5": "<sstring>",
    "col_6": "<sstream>",
    "col_7": "<string>",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 301,
    "col_2": "Which of the following header files is required for creating and reading data files?",
    "col_3": "ofstream.h",
    "col_4": "fstream.h",
    "col_5": "ifstream.h",
    "col_6": "console.h",
    "col_7": "fstream.h",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 302,
    "col_2": "What does a class in C++ holds?",
    "col_3": "data",
    "col_4": "functions",
    "col_5": "both data & functions",
    "col_6": "arrays",
    "col_7": "both data & functions",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 303,
    "col_2": "How many specifiers are present in access specifiers in class?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 3,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 304,
    "col_2": "Which is used to define the member of a class externally?",
    "col_3": ":",
    "col_4": "::",
    "col_5": "#",
    "col_6": "!!$",
    "col_7": "::",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 305,
    "col_2": "Which other keywords are also used to declare the class other than class?",
    "col_3": "struct",
    "col_4": "union",
    "col_5": "object",
    "col_6": "both struct & union",
    "col_7": "both struct & union",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 306,
    "col_2": "Which of the following is a valid class declaration?",
    "col_3": "class A { int x; };",
    "col_4": "class B { }",
    "col_5": "public class A { }",
    "col_6": "object A { int x; };",
    "col_7": "class A { int x; };",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 307,
    "col_2": "The data members and functions of a class in C++ are by default ____________",
    "col_3": "protected",
    "col_4": "private",
    "col_5": "public",
    "col_6": "public & protected",
    "col_7": "private",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 308,
    "col_2": "Constructors are used to ____________",
    "col_3": "initialize the objects",
    "col_4": "construct the data members",
    "col_5": "both initialize the objects & construct the data members",
    "col_6": "delete the objects",
    "col_7": "initialize the objects",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 309,
    "col_2": "When struct is used instead of the keyword class means, what will happen in the program?",
    "col_3": "access is public by default",
    "col_4": "access is private by default",
    "col_5": "access is protected by default",
    "col_6": "access is denied",
    "col_7": "access is public by default",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 310,
    "col_2": "Which category of data type a class belongs to?",
    "col_3": "Fundamental data type",
    "col_4": "Derived data type",
    "col_5": "User defined derived data type",
    "col_6": "Atomic data type",
    "col_7": "User defined derived data type",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 311,
    "col_2": "Which operator a pointer object of a class uses to access its data members and member functions?",
    "col_3": ".",
    "col_4": "->",
    "col_5": ":",
    "col_6": "::",
    "col_7": "->",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 312,
    "col_2": "How the objects are self-referenced in a member function of that class.",
    "col_3": "Using a special keyword object",
    "col_4": "Using this pointer",
    "col_5": "Using * with the name of that object",
    "col_6": "By passing self as a parameter in the member function",
    "col_7": "Using this pointer",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 313,
    "col_2": "What does a mutable member of a class mean?",
    "col_3": "A member that can never be changed",
    "col_4": "A member that can be updated only if it not a member of constant object",
    "col_5": "A member that can be updated even if it a member of constant object",
    "col_6": "A member that is global throughout the class",
    "col_7": "A member that can be updated even if it a member of constant object",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 314,
    "col_2": "Pick the incorrect statement about inline functions in C++?",
    "col_3": "They reduce function call overheads",
    "col_4": "These functions are inserted/substituted at the point of call",
    "col_5": "Saves overhead of a return call from a function",
    "col_6": "They are generally very large and complicated function",
    "col_7": "They are generally very large and complicated function",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 315,
    "col_2": "Inline functions are avoided when ____________________________",
    "col_3": "function contains static variables",
    "col_4": "function have recursive calls",
    "col_5": "function have loops",
    "col_6": "all of the mentioned",
    "col_7": "all of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 316,
    "col_2": "Pick the correct statement.",
    "col_3": "Macros and inline functions are same thing",
    "col_4": "Macros looks like function calls but they are actually not",
    "col_5": "Inline functions looks like function but they are not",
    "col_6": "Inline function are always large",
    "col_7": "Macros looks like function calls but they are actually not",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 317,
    "col_2": "Which keyword is used to define the user defined data types?",
    "col_3": "def",
    "col_4": "union",
    "col_5": "typedef",
    "col_6": "type",
    "col_7": "typedef",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 318,
    "col_2": "Identify the correct statement.",
    "col_3": "typedef does not create different types. It only creates synonyms of existing types",
    "col_4": "typedef create different types",
    "col_5": "typedef create own types",
    "col_6": "typedef will not creates synonyms of existing types",
    "col_7": "typedef does not create different types. It only creates synonyms of existing types",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 319,
    "col_2": "What does the data type defined by union will do?",
    "col_3": "It allow one different portion of memory to be accessed as same data types",
    "col_4": "It allow one same portion of memory to be accessed as same data types",
    "col_5": "It allow one different portion of memory to be accessed as different data types",
    "col_6": "It allow one same portion of memory to be accessed as different data types",
    "col_7": "It allow one same portion of memory to be accessed as different data types",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 320,
    "col_2": "What is the syntax of user-defined data types?",
    "col_3": "typedef ExistingDataType NameByUser",
    "col_4": "typedef NameByUser ExistingDataType",
    "col_5": "def NameByUser ExistingDataType",
    "col_6": "def NameByUser ExistingData",
    "col_7": "typedef ExistingDataType NameByUser",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 321,
    "col_2": "How many types of user-defined data type are in c++?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 3,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 322,
    "col_2": "What is the scope of typedef defined data types?",
    "col_3": "inside that block only",
    "col_4": "whole program",
    "col_5": "outside the program",
    "col_6": "main function",
    "col_7": "whole program",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 323,
    "col_2": "How many types of models are available to create the user-defined data type?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 2,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 324,
    "col_2": "Where does the object is created?",
    "col_3": "class",
    "col_4": "constructor",
    "col_5": "destructor",
    "col_6": "attributes",
    "col_7": "class",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 325,
    "col_2": "How to access the object in the class?",
    "col_3": "scope resolution operator",
    "col_4": "ternary operator",
    "col_5": "direct member access operator",
    "col_6": "resolution operator",
    "col_7": "direct member access operator",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 326,
    "col_2": "Which of these following members are not accessed by using direct member access operator?",
    "col_3": "public",
    "col_4": "private",
    "col_5": "protected",
    "col_6": "both private & protected",
    "col_7": "both private & protected",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 327,
    "col_2": "Pick out the other definition of objects.",
    "col_3": "member of the class",
    "col_4": "associate of the class",
    "col_5": "attribute of the class",
    "col_6": "instance of the class",
    "col_7": "instance of the class",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 328,
    "col_2": "How many objects can present in a single class?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": "as many as possible",
    "col_7": "as many as possible",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 329,
    "col_2": "Pick the other name of operator function.",
    "col_3": "function overloading",
    "col_4": "operator overloading",
    "col_5": "member overloading",
    "col_6": "object overloading",
    "col_7": "operator overloading",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 330,
    "col_2": "Which of the following operators can't be overloaded?",
    "col_3": "::",
    "col_4": "+",
    "col_5": "–",
    "col_6": [],
    "col_7": "::",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 331,
    "col_2": "How to declare operator function?",
    "col_3": "operator sign",
    "col_4": "operator",
    "col_5": "name of the operator",
    "col_6": "name of the class",
    "col_7": "operator sign",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 332,
    "col_2": "What is operator overloading in C++?",
    "col_3": "Overriding the operator meaning by the user defined meaning for user defined data type",
    "col_4": "Redefining the way operator works for user defined types",
    "col_5": "Ability to provide the operators with some special meaning for user defined data type",
    "col_6": "All of the mentioned",
    "col_7": "All of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 333,
    "col_2": "What is the syntax of overloading operator + for class A?",
    "col_3": "A operator+(argument_list){}",
    "col_4": "A operator[+](argument_list){}",
    "col_5": "int +(argument_list){}",
    "col_6": "int [+](argument_list){}",
    "col_7": "A operator+(argument_list){}",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 334,
    "col_2": "How many approaches are used for operator overloading?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 3,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 335,
    "col_2": "Which of the following operator cannot be overloaded?",
    "col_3": "+",
    "col_4": "?:",
    "col_5": "–",
    "col_6": "%",
    "col_7": "?:",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 336,
    "col_2": "Which of the following operator can be overloaded?",
    "col_3": "?:",
    "col_4": "::",
    "col_5": ".",
    "col_6": "==",
    "col_7": "==",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 337,
    "col_2": "In case of non-static member functions how many maximum object arguments a unary operator overloaded function can take?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 0,
    "col_7": 0,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 338,
    "col_2": "In case of non-static member functions how many maximum object arguments a binary operator overloaded function can take?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 0,
    "col_7": 1,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 339,
    "col_2": "In the case of friend operator overloaded functions how many maximum object arguments a unary operator overloaded function can take?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 0,
    "col_7": 1,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 340,
    "col_2": "In the case of friend operator overloaded functions how many maximum object arguments a binary operator overloaded function can take?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 0,
    "col_7": 2,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 341,
    "col_2": "What is a binary operator?",
    "col_3": "Operator that performs its action on a single operand",
    "col_4": "Operator that performs its action on two operand",
    "col_5": "Operator that performs its action on three operand",
    "col_6": "Operator that performs its action on any number of operands",
    "col_7": "Operator that performs its action on two operand",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 342,
    "col_2": "Which is the correct example of a binary operator?",
    "col_3": "++",
    "col_4": "—",
    "col_5": "Dereferencing operator(*)",
    "col_6": "+",
    "col_7": "+",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 343,
    "col_2": "Which is the correct example of a unary operator?",
    "col_3": "&",
    "col_4": "==",
    "col_5": "—",
    "col_6": "/",
    "col_7": "—",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 344,
    "col_2": "Which is the correct statement about operator overloading?",
    "col_3": "Only arithmetic operators can be overloaded",
    "col_4": "Only non-arithmetic operators can be overloaded",
    "col_5": "Precedence of operators are changed after overlaoding",
    "col_6": "Associativity and precedence of operators does not change",
    "col_7": "Associativity and precedence of operators does not change",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 345,
    "col_2": "Pick the incorrect statements out of the following.",
    "col_3": "Operator overloading does not disturbs the precedence of operators",
    "col_4": "Arity of operators can be changed using operator overloading",
    "col_5": "No new operators can be created",
    "col_6": "All of the mentioned",
    "col_7": "Arity of operators can be changed using operator overloading",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 346,
    "col_2": "Which header file is used to declare the complex number?",
    "col_3": "complexnum",
    "col_4": "complex",
    "col_5": "complex number",
    "col_6": "complexarg",
    "col_7": "complex",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 347,
    "col_2": "How to declare the complex number?",
    "col_3": "(3, 4)",
    "col_4": "complex(3, 4)",
    "col_5": "(3, 4i)",
    "col_6": "(3, 4g)",
    "col_7": "complex(3, 4)",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 348,
    "col_2": "How many real types are there in complex numbers?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 3,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 349,
    "col_2": "Which of the following is not a function of complex values?",
    "col_3": "real",
    "col_4": "imag",
    "col_5": "norm",
    "col_6": "cartesian",
    "col_7": "cartesian",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 350,
    "col_2": "What is the return type of the conversion operator?",
    "col_3": "void",
    "col_4": "int",
    "col_5": "float",
    "col_6": "no return type",
    "col_7": "no return type",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 351,
    "col_2": "Why we use the \"dynamic_cast\" type conversion?",
    "col_3": "result of the type conversion is a valid",
    "col_4": "to be used in low memory",
    "col_5": "result of the type conversion is an invalid",
    "col_6": "it is used for storage",
    "col_7": "result of the type conversion is a valid",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 352,
    "col_2": "How many parameters does a conversion operator may take?",
    "col_3": 0,
    "col_4": 1,
    "col_5": 2,
    "col_6": "as many as possible",
    "col_7": 0,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 353,
    "col_2": "How are types therein user-defined conversion?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 2,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 354,
    "col_2": "Pick out the correct syntax of operator conversion.",
    "col_3": "operator float()const",
    "col_4": "operator float()",
    "col_5": "operator const",
    "col_6": "operator const()",
    "col_7": "operator float()const",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 355,
    "col_2": "Which rule will not affect the friend function?",
    "col_3": "private and protected members of a class cannot be accessed from outside",
    "col_4": "private and protected member can be accessed anywhere",
    "col_5": "protected member can be accessed anywhere",
    "col_6": "private member can be accessed anywhere",
    "col_7": "private and protected members of a class cannot be accessed from outside",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 356,
    "col_2": "Which keyword is used to declare the friend function?",
    "col_3": "firend",
    "col_4": "friend",
    "col_5": "classfriend",
    "col_6": "myfriend",
    "col_7": "friend",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 357,
    "col_2": "What is the syntax of friend function?",
    "col_3": "friend class1 Class2;",
    "col_4": "friend class;",
    "col_5": "friend class",
    "col_6": "friend class()",
    "col_7": "friend class1 Class2;",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 358,
    "col_2": "Pick out the correct statement.",
    "col_3": "A friend function may be a member of another class",
    "col_4": "A friend function may not be a member of another class",
    "col_5": "A friend function may or may not be a member of another class",
    "col_6": "None of the mentioned",
    "col_7": "A friend function may or may not be a member of another class",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 359,
    "col_2": "Where does keyword 'friend' should be placed?",
    "col_3": "function declaration",
    "col_4": "function definition",
    "col_5": "main function",
    "col_6": "block function",
    "col_7": "function declaration",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 360,
    "col_2": "What is a friend function in C++?",
    "col_3": "A function which can access all the private, protected and public members of a class",
    "col_4": "A function which is not allowed to access any member of any class",
    "col_5": "A function which is allowed to access public and protected members of a class",
    "col_6": "A function which is allowed to access only public members of a class",
    "col_7": "A function which can access all the private, protected and public members of a class",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 361,
    "col_2": "Pick the correct statement.",
    "col_3": "Friend functions are in the scope of a class",
    "col_4": "Friend functions can be called using class objects",
    "col_5": "Friend functions can be invoked as a normal function",
    "col_6": "Friend functions can access only protected members not the private members",
    "col_7": "Friend functions can be invoked as a normal function",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 362,
    "col_2": "Which of the following is correct about friend functions?",
    "col_3": "Friend functions use the dot operator to access members of a class using class objects",
    "col_4": "Friend functions can be private or public",
    "col_5": "Friend cannot access the members of the class directly",
    "col_6": "All of the mentioned",
    "col_7": "All of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 363,
    "col_2": "Which keyword is used to represent a friend function?",
    "col_3": "friend",
    "col_4": "Friend",
    "col_5": "friend_func",
    "col_6": "Friend_func",
    "col_7": "friend",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 364,
    "col_2": "How to store the large objects in c++ if it extends its allocated memory?",
    "col_3": "memory heap",
    "col_4": "stack",
    "col_5": "queue",
    "col_6": "stack & queue",
    "col_7": "memory heap",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 365,
    "col_2": "When we are using heap operations what do we need to do to save the memory?",
    "col_3": "rename the objects",
    "col_4": "delete the objects after processing",
    "col_5": "both rename & delete the objects",
    "col_6": "add the objects",
    "col_7": "delete the objects after processing",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 366,
    "col_2": "Which container in c++ will take large objects?",
    "col_3": "string",
    "col_4": "class",
    "col_5": "vector",
    "col_6": "string & class",
    "col_7": "vector",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 367,
    "col_2": "How to stop your program from eating so much ram?",
    "col_3": "Find a way to work with the data one at a time",
    "col_4": "Declare it in program memory, instead of on the stack",
    "col_5": "Use the hard drive, instead of RAM",
    "col_6": "All of the mentioned",
    "col_7": "All of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 368,
    "col_2": "Which option is best to eliminate the memory problem?",
    "col_3": "use smart pointers",
    "col_4": "use raw pointers",
    "col_5": "use virtual destructor",
    "col_6": "use smart pointers & virtual destructor",
    "col_7": "use smart pointers & virtual destructor",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 369,
    "col_2": "What is the size of the heap?",
    "col_3": "10MB",
    "col_4": "500MB",
    "col_5": "1GB",
    "col_6": "Size of the heap memory is limited by the size of the RAM and the swap memory",
    "col_7": "Size of the heap memory is limited by the size of the RAM and the swap memory",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 370,
    "col_2": "How to unlimit the size of the stack?",
    "col_3": "setrlimit()",
    "col_4": "unlimit()",
    "col_5": "both setrlimit() & unlimit()",
    "col_6": "setflimit()",
    "col_7": "setrlimit()",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 371,
    "col_2": "In Linux, how do the heaps and stacks are managed?",
    "col_3": "ram",
    "col_4": "secondary memory",
    "col_5": "virtual memory",
    "col_6": "static memory",
    "col_7": "virtual memory",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 372,
    "col_2": "Which is used to pass the large objects in c++?",
    "col_3": "pass by value",
    "col_4": "pass by reference",
    "col_5": "both pass by value & reference",
    "col_6": "pass by name",
    "col_7": "pass by reference",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 373,
    "col_2": "In which direction does the assignment operation will take place?",
    "col_3": "left to right",
    "col_4": "right to left",
    "col_5": "top to bottom",
    "col_6": "bottom to top",
    "col_7": "right to left",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 374,
    "col_2": "Pick out the compound assignment statement.",
    "col_3": "a = a – 5",
    "col_4": "a = a / b",
    "col_5": "a -= 5",
    "col_6": "a = a + 5",
    "col_7": "a -= 5",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 375,
    "col_2": "What is the associativity of add(+);?",
    "col_3": "right to left",
    "col_4": "left to right",
    "col_5": "right to left & left to right",
    "col_6": "top to bottom",
    "col_7": "left to right",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 376,
    "col_2": "Which operator is having the highest precedence in c++?",
    "col_3": "array subscript",
    "col_4": "Scope resolution operator",
    "col_5": "static_cast",
    "col_6": "dynamic_cast",
    "col_7": "Scope resolution operator",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 377,
    "col_2": "subscript operator is used to access which elements?",
    "col_3": "string",
    "col_4": "char",
    "col_5": "array",
    "col_6": "float",
    "col_7": "array",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 378,
    "col_2": "How many arguments will the subscript operator will take for overloading?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 0,
    "col_6": "as many as possible",
    "col_7": 1,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 379,
    "col_2": "Pick out the correct statement.",
    "col_3": "subscript operator has a higher precedence than the assignment operator",
    "col_4": "subscript operator has a lower precedence than the assignment operator",
    "col_5": "subscript operator is used with string elements",
    "col_6": "subscript operator is used with char elements",
    "col_7": "subscript operator has a higher precedence than the assignment operator",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 380,
    "col_2": "What do we need to do to pointer for overloading the subscript operator?",
    "col_3": "reference pointer",
    "col_4": "dereference pointer",
    "col_5": "store it in heap",
    "col_6": "memory locator",
    "col_7": "dereference pointer",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 381,
    "col_2": "What do we need to use when we have multiple subscripts?",
    "col_3": "operator()",
    "col_4": "operator[]",
    "col_5": "operator",
    "col_6": "operator<>",
    "col_7": "operator()",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 382,
    "col_2": "What is the use of function call operator?",
    "col_3": "overloading the methods",
    "col_4": "overloading the objects",
    "col_5": "overloading the parameters",
    "col_6": "overloading the string",
    "col_7": "overloading the objects",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 383,
    "col_2": "Pick out the correct statement.",
    "col_3": "virtual functions does not give the ability to write a templated function",
    "col_4": "virtual functions does not give the ability to rewrite a templated function",
    "col_5": "virtual functions does give the ability to write a templated function",
    "col_6": "virtual functions does not give the ability to rewrite a simple function",
    "col_7": "virtual functions does not give the ability to write a templated function",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 384,
    "col_2": "What is the use of functor?",
    "col_3": "It makes the object \"callable\" like a function",
    "col_4": "It makes the class \"callable\" like a function",
    "col_5": "It makes the attribute \"callable\" like a function",
    "col_6": "It makes the argument \"callable\" like a function",
    "col_7": "It makes the object \"callable\" like a function",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 385,
    "col_2": "Which is used to tell the computer that where a pointer is pointing to?",
    "col_3": "dereference",
    "col_4": "reference",
    "col_5": "heap operations",
    "col_6": "binary operations",
    "col_7": "dereference",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 386,
    "col_2": "Which is used to do the dereferencing?",
    "col_3": "pointer without asterix",
    "col_4": "value without asterix",
    "col_5": "pointer with asterix",
    "col_6": "value with asterix",
    "col_7": "pointer with asterix",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 387,
    "col_2": "Pick out the correct option.",
    "col_3": "References automatically dereference without needing an extra character",
    "col_4": "References automatically dereference with an extra character",
    "col_5": "Reference will not dereference",
    "col_6": "Reference automatically dereference with extra space and character",
    "col_7": "References automatically dereference without needing an extra character",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 388,
    "col_2": "What does the dereference operator will return?",
    "col_3": "rvalue equivalent to the value at the pointer address",
    "col_4": "lvalue equivalent to the value at the pointer address",
    "col_5": "it will return nothing",
    "col_6": "it will return boolean values",
    "col_7": "lvalue equivalent to the value at the pointer address",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 389,
    "col_2": "Pick out the correct statement.",
    "col_3": "the null pointer dereference occurs where a pointer that is expected to be a valid address but instead is equal to null",
    "col_4": "the null pointer dereference occurs where a pointer that is expected to be a valid address but instead is equal to the memory address",
    "col_5": "rvalue equivalent to the value at the pointer address",
    "col_6": "null pointer will not return anything",
    "col_7": "the null pointer dereference occurs where a pointer that is expected to be a valid address but instead is equal to null",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 390,
    "col_2": "Which operator works only with integer variables?",
    "col_3": "increment",
    "col_4": "decrement",
    "col_5": "both increment & decrement",
    "col_6": "binary operator",
    "col_7": "both increment & decrement",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 391,
    "col_2": "How many types are there in increment/decrement operator?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 2,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 392,
    "col_2": "Pick out the correct statement.",
    "col_3": "Increment operator ++ adds 1 to its operand",
    "col_4": "Increment operator ++ adds 2 to its operand",
    "col_5": "Decrement operator ++ subtracts 1 to its operand",
    "col_6": "Decrement operator ++ subtracts 3 to its operand",
    "col_7": "Increment operator ++ adds 1 to its operand",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 393,
    "col_2": "Pick out the correct statement.",
    "col_3": "Pre Increment is faster than post-increment",
    "col_4": "post-increment is faster than Pre Increment",
    "col_5": "pre increment is slower than post-increment",
    "col_6": "pre decrement is slower than post-increment",
    "col_7": "Pre Increment is faster than post-increment",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 394,
    "col_2": "Which concepts does the Pre Increment use?",
    "col_3": "call by value",
    "col_4": "call by reference",
    "col_5": "queue",
    "col_6": "call by name",
    "col_7": "call by reference",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 395,
    "col_2": "How many types of representation are in the string?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 2,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 396,
    "col_2": "What is the header file for the string class?",
    "col_3": "#include<ios>",
    "col_4": "#include<str>",
    "col_5": "#include<string>",
    "col_6": "#include<stio>",
    "col_7": "#include<string>",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 397,
    "col_2": "Which is used to return the number of characters in the string?",
    "col_3": "length",
    "col_4": "size",
    "col_5": "both size & length",
    "col_6": "name",
    "col_7": "both size & length",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 398,
    "col_2": "Which method do we use to append more than one character at a time?",
    "col_3": "append",
    "col_4": "operator+=",
    "col_5": "data",
    "col_6": "both append & operator+=",
    "col_7": "both append & operator+=",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 399,
    "col_2": "What is string objects in C++?",
    "col_3": "Stream of alphabets",
    "col_4": "A stream of well-defined characters",
    "col_5": "Stream of characters",
    "col_6": "A stream of characters terminated by",
    "col_7": "A stream of well-defined characters",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 400,
    "col_2": "What is Character-Array?",
    "col_3": "array of alphabets",
    "col_4": "array of well-defined characters",
    "col_5": "array of characters",
    "col_6": "array of characters terminated by",
    "col_7": "array of characters",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 401,
    "col_2": "Pick the incorrect statement about Character-Array.",
    "col_3": "Character-Array can be terminated by a null character('",
    "col_4": "0')",
    "col_5": "Character-Array has a static size",
    "col_6": "Character-Array has a dynamic size",
    "col_7": "Character-Array has a static size",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 402,
    "col_2": "Pick the correct statement about string objects in C++.",
    "col_3": "String objects must be terminated by a null character('",
    "col_4": "0')",
    "col_5": "String objects have a static size",
    "col_6": "String objects have a dynamic size",
    "col_7": "String objects have a static size",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 403,
    "col_2": "Which of the following is not a modifier function in string class?",
    "col_3": "operator+=()",
    "col_4": "operator[]()",
    "col_5": "push_back()",
    "col_6": "erase()",
    "col_7": "operator[]()",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 404,
    "col_2": "Which function is used to get the length of a string object?",
    "col_3": "str.length()",
    "col_4": "str.size()",
    "col_5": "str.max_size()",
    "col_6": "both size() and length() function",
    "col_7": "both size() and length() function",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 405,
    "col_2": "What is the identifier given to string class to declare string objects?",
    "col_3": "String",
    "col_4": "string",
    "col_5": "STRING",
    "col_6": "Any of the above can be used",
    "col_7": "string",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 406,
    "col_2": "What is the role of a constructor in classes?",
    "col_3": "To modify the data whenever required",
    "col_4": "To destroy an object",
    "col_5": "To initialize the data members of an object when it is created",
    "col_6": "To call private functions from the outer world",
    "col_7": "To initialize the data members of an object when it is created",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 407,
    "col_2": "Why constructors are efficient instead of a function init() defined by the user to initialize the data members of an object?",
    "col_3": "Because user may forget to call init() using that object leading segmentation fault",
    "col_4": "Because user may call init() more than once which leads to overwriting values",
    "col_5": "Because user may forget to define init() function",
    "col_6": "All of the mentioned",
    "col_7": "All of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 408,
    "col_2": "What is a copy constructor?",
    "col_3": "A constructor that allows a user to move data from one object to another",
    "col_4": "A constructor to initialize an object with the values of another object",
    "col_5": "A constructor to check the whether to objects are equal or not",
    "col_6": "A constructor to kill other copies of a given object.",
    "col_7": "A constructor to initialize an object with the values of another object",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 409,
    "col_2": "What happens if a user forgets to define a constructor inside a class?",
    "col_3": "Error occurs",
    "col_4": "Segmentation fault",
    "col_5": "Objects are not created properly",
    "col_6": "Compiler provides a default constructor to avoid faults/errors",
    "col_7": "Compiler provides a default constructor to avoid faults/errors",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 410,
    "col_2": "How many parameters does a default constructor require?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 0,
    "col_6": 3,
    "col_7": 0,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 411,
    "col_2": "How constructors are different from other member functions of the class?",
    "col_3": "Constructor has the same name as the class itself",
    "col_4": "Constructors do not return anything",
    "col_5": "Constructors are automatically called when an object is created",
    "col_6": "All of the mentioned",
    "col_7": "All of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 412,
    "col_2": "How many types of constructors are there in C++?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 3,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 413,
    "col_2": "What is the role of destructors in Classes?",
    "col_3": "To modify the data whenever required",
    "col_4": "To destroy an object when the lifetime of an object ends",
    "col_5": "To initialize the data members of an object when it is created",
    "col_6": "To call private functions from the outer world",
    "col_7": "To destroy an object when the lifetime of an object ends",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 414,
    "col_2": "What is syntax of defining a destructor of class A?",
    "col_3": "A(){}",
    "col_4": "~A(){}",
    "col_5": "A::A(){}",
    "col_6": "~A(){};",
    "col_7": "~A(){}",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 415,
    "col_2": "When destructors are called?",
    "col_3": "When a program ends",
    "col_4": "When a function ends",
    "col_5": "When a delete operator is used",
    "col_6": "All of the mentioned",
    "col_7": "All of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 416,
    "col_2": "What is the difference between constructors and destructors?",
    "col_3": "They have a different function name",
    "col_4": "Constructors does not have return type whereas destructors do have",
    "col_5": "Constructors allow function parameters whereas destructors do not",
    "col_6": "Constructors does not function parameters",
    "col_7": "Constructors allow function parameters whereas destructors do not",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 417,
    "col_2": "How many Destructors are allowed in a Class?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": "Any number",
    "col_7": 1,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 418,
    "col_2": "Which of the following constructors are provided by the C++ compiler if not defined in a class?",
    "col_3": "Default constructor",
    "col_4": "Assignment constructor",
    "col_5": "Copy constructor",
    "col_6": "All of the mentioned",
    "col_7": "All of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 419,
    "col_2": "When a copy constructor is called?",
    "col_3": "When an object of the class is returned by value",
    "col_4": "When an object of the class is passed by value to a function",
    "col_5": "When an object is constructed based on another object of the same class",
    "col_6": "All of the mentioned",
    "col_7": "All of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 420,
    "col_2": "How destructor overloading is done?",
    "col_3": "By changing the number of parameters",
    "col_4": "By changing the parameters type",
    "col_5": "By changing both the number of parameters and their type",
    "col_6": "No chance for destructor overloading",
    "col_7": "No chance for destructor overloading",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 421,
    "col_2": "Which of the following is correct?",
    "col_3": "Destructors can be virtual",
    "col_4": "There can be more than one destructor in a class",
    "col_5": "Destructor definition starts with !",
    "col_6": "Destructor is used to initialize objects",
    "col_7": "Destructors can be virtual",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 422,
    "col_2": "Where is the derived class is derived from?",
    "col_3": "derived",
    "col_4": "base",
    "col_5": "both derived & base",
    "col_6": "class",
    "col_7": "base",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 423,
    "col_2": "Pick out the correct statement.",
    "col_3": "A derived class's constructor cannot explicitly invokes its base class's constructor",
    "col_4": "A derived class's destructor cannot invoke its base class's destructor",
    "col_5": "A derived class's destructor can invoke its base class's destructor",
    "col_6": "A derived class's destructor can invoke its base & derived class's destructor",
    "col_7": "A derived class's destructor cannot invoke its base class's destructor",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 424,
    "col_2": "Which of the following can derived class inherit?",
    "col_3": "members",
    "col_4": "functions",
    "col_5": "both members & functions",
    "col_6": "classes",
    "col_7": "both members & functions",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 425,
    "col_2": "Which operator is used to declare the destructor?",
    "col_3": "#",
    "col_4": "~",
    "col_5": "@",
    "col_6": "$",
    "col_7": "~",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 426,
    "col_2": "Which constructor will initialize the base class data member?",
    "col_3": "derived class",
    "col_4": "base class",
    "col_5": "class",
    "col_6": "derived & base class",
    "col_7": "base class",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 427,
    "col_2": "Which class is used to design the base class?",
    "col_3": "abstract class",
    "col_4": "derived class",
    "col_5": "base class",
    "col_6": "derived & base class",
    "col_7": "abstract class",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 428,
    "col_2": "Which is used to create a pure virtual function?",
    "col_3": "$",
    "col_4": "=0",
    "col_5": "&",
    "col_6": "!",
    "col_7": "=0",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 429,
    "col_2": "Which is also called as abstract class?",
    "col_3": "virtual function",
    "col_4": "pure virtual function",
    "col_5": "derived class",
    "col_6": "base class",
    "col_7": "pure virtual function",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 430,
    "col_2": "What is meant by pure virtual function?",
    "col_3": "Function which does not have definition of its own",
    "col_4": "Function which does have definition of its own",
    "col_5": "Function which does not have any return type",
    "col_6": "Function which does not have any return type & own definition",
    "col_7": "Function which does not have definition of its own",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 431,
    "col_2": "Pick out the correct option.",
    "col_3": "We cannot make an instance of an abstract base class",
    "col_4": "We can make an instance of an abstract base class",
    "col_5": "We can make an instance of an abstract super class",
    "col_6": "We can make an instance of an abstract derived class",
    "col_7": "We cannot make an instance of an abstract base class",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 432,
    "col_2": "Where does the abstract class is used?",
    "col_3": "base class only",
    "col_4": "derived class",
    "col_5": "both derived & base class",
    "col_6": "virtual class",
    "col_7": "base class only",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 433,
    "col_2": "What is an abstract class in C++?",
    "col_3": "Class specifically used as a base class with atleast one virtual functions",
    "col_4": "Class specifically used as a base class with atleast one pure virtual functions",
    "col_5": "Class from which any class is derived",
    "col_6": "Any Class in C++ is an abstract class",
    "col_7": "Class specifically used as a base class with atleast one pure virtual functions",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 434,
    "col_2": "What is a pure virtual function in C++?",
    "col_3": "A virtual function defined in a base class",
    "col_4": "A virtual function declared in a base class",
    "col_5": "Any function in a class",
    "col_6": "A function without definition in a base class",
    "col_7": "A virtual function declared in a base class",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 435,
    "col_2": "Which is the correct syntax of defining a pure virtual function?",
    "col_3": "pure virtual return_type func();",
    "col_4": "virtual return_type func() pure;",
    "col_5": "virtual return_type func() = 0;",
    "col_6": "virtual return_type func();",
    "col_7": "virtual return_type func() = 0;",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 436,
    "col_2": "Which is the correct statement about pure virtual functions?",
    "col_3": "They should be defined inside a base class",
    "col_4": "Pure keyword should be used to declare a pure virtual function",
    "col_5": "Pure virtual function is implemented in derived classes",
    "col_6": "Pure virtual function cannot implemented in derived classes",
    "col_7": "Pure virtual function is implemented in derived classes",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 437,
    "col_2": "Pick the correct statement.",
    "col_3": "Pure virtual functions and virtual functions are the same",
    "col_4": "Both Pure virtual function and virtual function have an implementation in the base class",
    "col_5": "Pure virtual function has no implementation in the base class whereas virtual function may have an implementation in the base class",
    "col_6": "The base class has no pure virtual function",
    "col_7": "Pure virtual function has no implementation in the base class whereas virtual function may have an implementation in the base class",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 438,
    "col_2": "Which interface determines how your class will be used by another program?",
    "col_3": "public",
    "col_4": "private",
    "col_5": "protected",
    "col_6": "void",
    "col_7": "public",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 439,
    "col_2": "Pick out the correct statement about the override.",
    "col_3": "Overriding refers to a derived class function that has the same name and signature as a base class virtual function",
    "col_4": "Overriding has different names",
    "col_5": "Overriding refers to a derived class",
    "col_6": "Overriding has different names & it refers to a derived class",
    "col_7": "Overriding refers to a derived class function that has the same name and signature as a base class virtual function",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 440,
    "col_2": "How many ways of reusing are there in the class hierarchy?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 2,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 441,
    "col_2": "How many types of class are there in c++?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 3,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 442,
    "col_2": "Pick out the correct statement about multiple inheritances.",
    "col_3": "Deriving a class from one direct base class",
    "col_4": "Deriving a class from more than one direct base class",
    "col_5": "Deriving a class from more than one direct derived class",
    "col_6": "Deriving a class from more than one direct derivedbase class",
    "col_7": "Deriving a class from more than one direct base class",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 443,
    "col_2": "What does inheritance allow you to do?",
    "col_3": "create a class",
    "col_4": "create a hierarchy of classes",
    "col_5": "access methods",
    "col_6": "create a method",
    "col_7": "create a hierarchy of classes",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 444,
    "col_2": "What is the syntax of inheritance of class?",
    "col_3": "class name",
    "col_4": "class name: access specifier",
    "col_5": "class name: access specifier class name",
    "col_6": "access specifier class name",
    "col_7": "class name: access specifier class name",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 445,
    "col_2": "How many kinds of classes are there in c++?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 2,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 446,
    "col_2": "What is meant by polymorphism?",
    "col_3": "class having many forms",
    "col_4": "class having only single form",
    "col_5": "class having two forms",
    "col_6": "class having four forms",
    "col_7": "class having many forms",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 447,
    "col_2": "How many types of inheritance are there in c++?",
    "col_3": 2,
    "col_4": 3,
    "col_5": 4,
    "col_6": 5,
    "col_7": 5,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 448,
    "col_2": "What is meant by container ship?",
    "col_3": "class contains objects of other class types as its members",
    "col_4": "class contains objects of other class types as its objects",
    "col_5": "class contains objects of other class types as its members 7 also objects",
    "col_6": "class contains objects of other class types as its members 9 also objects",
    "col_7": "class contains objects of other class types as its members",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 449,
    "col_2": "How many types of the constructor are there in C++?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 3,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 450,
    "col_2": "How many constructors can present in a class?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": "multiple",
    "col_7": "multiple",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 451,
    "col_2": "What should be the name of the constructor?",
    "col_3": "same as the object",
    "col_4": "same as the member",
    "col_5": "same as the class",
    "col_6": "same as the function",
    "col_7": "same as the class",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 452,
    "col_2": "What does derived class does not inherit from the base class?",
    "col_3": "constructor and destructor",
    "col_4": "friends",
    "col_5": "operator = () members",
    "col_6": "all of the mentioned",
    "col_7": "all of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 453,
    "col_2": "What is a template?",
    "col_3": "A template is a formula for creating a generic class",
    "col_4": "A template is used to manipulate the class",
    "col_5": "A template is used for creating the attributes",
    "col_6": "A template is used to delete the class",
    "col_7": "A template is a formula for creating a generic class",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 454,
    "col_2": "Pick out the correct statement about string template.",
    "col_3": "It is used to replace a string",
    "col_4": "It is used to replace a string with another string at runtime",
    "col_5": "It is used to delete a string",
    "col_6": "It is used to create a string",
    "col_7": "It is used to replace a string with another string at runtime",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 455,
    "col_2": "How to declare a template?",
    "col_3": "tem",
    "col_4": "temp",
    "col_5": "template<>",
    "col_6": "temp()",
    "col_7": "template<>",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 456,
    "col_2": "How many types of templates are there in c++?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 2,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 457,
    "col_2": "Which are done by compiler for templates?",
    "col_3": "type-safe",
    "col_4": "portability",
    "col_5": "code elimination",
    "col_6": "prototype",
    "col_7": "type-safe",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 458,
    "col_2": "What may be the name of the parameter that the template should take?",
    "col_3": "same as template",
    "col_4": "same as class",
    "col_5": "same as function",
    "col_6": "same as member",
    "col_7": "same as template",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 459,
    "col_2": "How many parameters are legal for non-type template?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 4,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 460,
    "col_2": "What is a function template?",
    "col_3": "creating a function without having to specify the exact type",
    "col_4": "creating a function with having an exact type",
    "col_5": "creating a function without having blank spaces",
    "col_6": "creating a function without class",
    "col_7": "creating a function without having to specify the exact type",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 461,
    "col_2": "Which is used to describe the function using placeholder types?",
    "col_3": "template parameters",
    "col_4": "template type parameters",
    "col_5": "template type",
    "col_6": "type parameters",
    "col_7": "template type parameters",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 462,
    "col_2": "Pick out the correct statement.",
    "col_3": "you only need to write one function, and it will work with many different types",
    "col_4": "it will take a long time to execute",
    "col_5": "duplicate code is increased",
    "col_6": "it will take a long time to execute & duplicate code is increased",
    "col_7": "you only need to write one function, and it will work with many different types",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 463,
    "col_2": "What can be passed by non-type template parameters during compile time?",
    "col_3": "int",
    "col_4": "float",
    "col_5": "constant expression",
    "col_6": "string",
    "col_7": "constant expression",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 464,
    "col_2": "From where does the template class derived?",
    "col_3": "regular non-templated C++ class",
    "col_4": "templated class",
    "col_5": "regular non-templated C++ class or templated class",
    "col_6": "main function",
    "col_7": "regular non-templated C++ class or templated class",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 465,
    "col_2": "What are Templates in C++?",
    "col_3": "A feature that allows the programmer to write generic programs",
    "col_4": "A feature that allows the programmer to write specific codes for a problem",
    "col_5": "A feature that allows the programmer to make program modular",
    "col_6": "A feature that does not add any power to the language",
    "col_7": "A feature that allows the programmer to write generic programs",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 466,
    "col_2": "In how many ways templates concept can be used?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 2,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 467,
    "col_2": "What is the difference between normal function and template function?",
    "col_3": "The normal function works with any data types whereas template function works with specific types only",
    "col_4": "Template function works with any data types whereas normal function works with specific types only",
    "col_5": "Unlike a normal function, the template function accepts a single parameter",
    "col_6": "Unlike the template function, the normal function accepts more than one parameters",
    "col_7": "Template function works with any data types whereas normal function works with specific types only",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 468,
    "col_2": "Templates simulate which of the following feature?",
    "col_3": "Polymorphism",
    "col_4": "Abstraction",
    "col_5": "Encapsulation",
    "col_6": "Inheritance",
    "col_7": "Polymorphism",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 469,
    "col_2": "Which keyword is used for the template?",
    "col_3": "Template",
    "col_4": "template",
    "col_5": "Temp",
    "col_6": "temp",
    "col_7": "template",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 470,
    "col_2": "What is the correct syntax of defining function template/template functions?",
    "col_3": "template <class T> void(T a){cout<<a;}",
    "col_4": "Template <class T> void(T a){cout<<a;}",
    "col_5": "template <T> void(T a){cout<<a;}",
    "col_6": "Template <T> void(T a){cout<<a;}",
    "col_7": "template <class T> void(T a){cout<<a;}",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 471,
    "col_2": "What are Templates in C++?",
    "col_3": "A feature that allows the programmer to write generic programs",
    "col_4": "A feature that allows the programmer to write specific codes for a problem",
    "col_5": "A feature that allows the programmer to make program modular",
    "col_6": "A feature that does not add any power to the language",
    "col_7": "A feature that allows the programmer to write generic programs",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 472,
    "col_2": "In how many ways templates concept can be used?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 2,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 473,
    "col_2": "What is the difference between normal function and template function?",
    "col_3": "The normal function works with any data types whereas template function works with specific types only",
    "col_4": "Template function works with any data types whereas normal function works with specific types only",
    "col_5": "Unlike a normal function, the template function accepts a single parameter",
    "col_6": "Unlike the template function, the normal function accepts more than one parameters",
    "col_7": "Template function works with any data types whereas normal function works with specific types only",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 474,
    "col_2": "Templates simulate which of the following feature?",
    "col_3": "Polymorphism",
    "col_4": "Abstraction",
    "col_5": "Encapsulation",
    "col_6": "Inheritance",
    "col_7": "Polymorphism",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 475,
    "col_2": "Which keyword is used for the template?",
    "col_3": "Template",
    "col_4": "template",
    "col_5": "Temp",
    "col_6": "temp",
    "col_7": "template",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 476,
    "col_2": "What is the correct syntax of defining function template/template functions?",
    "col_3": "template <class T> void(T a){cout<<a;}",
    "col_4": "Template <class T> void(T a){cout<<a;}",
    "col_5": "template <T> void(T a){cout<<a;}",
    "col_6": "Template <T> void(T a){cout<<a;}",
    "col_7": "template <class T> void(T a){cout<<a;}",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 477,
    "col_2": "What is the syntax of class template?",
    "col_3": "template <paramaters> class declaration",
    "col_4": "Template <paramaters> class declaration",
    "col_5": "temp <paramaters> class declaration",
    "col_6": "Temp <paramaters> class declaration",
    "col_7": "template <paramaters> class declaration",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 478,
    "col_2": "What is meant by the template parameter?",
    "col_3": "It can be used to pass a type as an argument",
    "col_4": "It can be used to evaluate a type",
    "col_5": "It can of no return type",
    "col_6": "It can be used to delete a type",
    "col_7": "It can be used to pass a type as an argument",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 479,
    "col_2": "Which keyword can be used in template?",
    "col_3": "class",
    "col_4": "typename",
    "col_5": "both class & typename",
    "col_6": "function",
    "col_7": "both class & typename",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 480,
    "col_2": "What is the validity of template parameters?",
    "col_3": "inside that block only",
    "col_4": "inside the class",
    "col_5": "whole program",
    "col_6": "inside the main class",
    "col_7": "inside that block only",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 481,
    "col_2": "Why we use :: template-template parameter?",
    "col_3": "binding",
    "col_4": "rebinding",
    "col_5": "both binding & rebinding",
    "col_6": "reusing",
    "col_7": "both binding & rebinding",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 482,
    "col_2": "Which parameter is legal for non-type template?",
    "col_3": "pointer to member",
    "col_4": "object",
    "col_5": "class",
    "col_6": "baseclass",
    "col_7": "pointer to member",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 483,
    "col_2": "Which of the things does not require instantiation?",
    "col_3": "functions",
    "col_4": "non virtual member function",
    "col_5": "member class",
    "col_6": "all of the mentioned",
    "col_7": "all of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 484,
    "col_2": "What is meant by template specialization?",
    "col_3": "It will have certain data types to be fixed",
    "col_4": "It will make certain data types to be dynamic",
    "col_5": "Certain data types are invalid",
    "col_6": "It will make all data types to be dynamic",
    "col_7": "It will have certain data types to be fixed",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 485,
    "col_2": "Which is similar to template specialization?",
    "col_3": "template",
    "col_4": "function overloading",
    "col_5": "function template overloading",
    "col_6": "overloading",
    "col_7": "function template overloading",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 486,
    "col_2": "Which is called on allocating the memory for the array of objects?",
    "col_3": "destructor",
    "col_4": "constructor",
    "col_5": "method",
    "col_6": "class",
    "col_7": "constructor",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 487,
    "col_2": "How many types of specialization are there in c++?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 2,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 488,
    "col_2": "What is another name of full specialization?",
    "col_3": "explicit specialization",
    "col_4": "implicit specialization",
    "col_5": "function overloading template",
    "col_6": "overloading template",
    "col_7": "explicit specialization",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 489,
    "col_2": "Which is dependant on template parameter?",
    "col_3": "base class",
    "col_4": "abstract class",
    "col_5": "method",
    "col_6": "static class",
    "col_7": "base class",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 490,
    "col_2": "Which value is placed in the base class?",
    "col_3": "derived values",
    "col_4": "default type values",
    "col_5": "both default type & derived values",
    "col_6": "null value",
    "col_7": "default type values",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 491,
    "col_2": "How many bits of memory needed for internal representation of class?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 4,
    "col_6": "no memory needed",
    "col_7": "no memory needed",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 492,
    "col_2": "What is the Standard Template Library?",
    "col_3": "Set of C++ template classes to provide common programming data structures and functions",
    "col_4": "Set of C++ classes",
    "col_5": "Set of Template functions used for easy data structures implementation",
    "col_6": "Set of Template data structures only",
    "col_7": "Set of C++ template classes to provide common programming data structures and functions",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 493,
    "col_2": "Pick the correct statement.",
    "col_3": "STL is a generalized library",
    "col_4": "Components of STL are parameterized",
    "col_5": "STL uses the concept of templates classes and functions to achieve generalized implementation",
    "col_6": "All of the mentioned",
    "col_7": "All of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 494,
    "col_2": "How many components STL has?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 4,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 495,
    "col_2": "What are the containers?",
    "col_3": "Containers store objects and data",
    "col_4": "Containers stores all the algorithms",
    "col_5": "Containers contain overloaded functions",
    "col_6": "Containers contain set of Iterators",
    "col_7": "Containers store objects and data",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 496,
    "col_2": "In how many categories, containers are divided?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 4,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 497,
    "col_2": "What are the Sequence Containers?",
    "col_3": "Containers that implements data structures which can be accessed sequentially",
    "col_4": "Containers that implements sorted data structures for fast search in O(logn)",
    "col_5": "Containers that implements unsorted(hashed) data structures for quick search in O(1)",
    "col_6": "Containers that implements data structures which can be accessed non-sequentially",
    "col_7": "Containers that implements data structures which can be accessed sequentially",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 498,
    "col_2": "How many Sequence Containers are provided by C++?",
    "col_3": 2,
    "col_4": 3,
    "col_5": 4,
    "col_6": 5,
    "col_7": 5,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 499,
    "col_2": "What are the Associative Containers?",
    "col_3": "Containers that implements data structures which can be accessed sequentially",
    "col_4": "Containers that implements sorted data structures for fast search in O(logn)",
    "col_5": "Containers that implements unsorted(hashed) data structures for quick search in O(1)",
    "col_6": "Containers that implements data structures which can be accessed non-sequentially",
    "col_7": "Containers that implements sorted data structures for fast search in O(logn)",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 500,
    "col_2": "How many Associative Containers are provided by C++?",
    "col_3": 2,
    "col_4": 3,
    "col_5": 4,
    "col_6": 5,
    "col_7": 4,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 501,
    "col_2": "What are Unordered Associative Containers?",
    "col_3": "Containers that implements data structures which can be accessed sequentially",
    "col_4": "Containers that implements sorted data structures for fast search in O(logn)",
    "col_5": "Containers that implements unsorted(hashed) data structures for quick search in O(1)",
    "col_6": "Containers that implements data structures which can be accessed non-sequentially",
    "col_7": "Containers that implements unsorted(hashed) data structures for quick search in O(1)",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 502,
    "col_2": "What are Container Adaptors?",
    "col_3": "Containers that implements data structures which can be accessed sequentially",
    "col_4": "Containers that implements sorted data structures for fast search in O(logn)",
    "col_5": "Containers that implements unsorted(hashed) data structures for quick search in O(1)",
    "col_6": "Containers that provide a different interface for sequential containers",
    "col_7": "Containers that provide a different interface for sequential containers",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 503,
    "col_2": "How many Container Adaptors are provided by C++?",
    "col_3": 2,
    "col_4": 3,
    "col_5": 4,
    "col_6": 5,
    "col_7": 3,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 504,
    "col_2": "What are Iterators?",
    "col_3": "Iterators are used to iterate over C-like arrays",
    "col_4": "Iterators are used to iterate over pointers",
    "col_5": "Iterators are used to point memory addresses of STL containers",
    "col_6": "Iterators are used to iterate over functions",
    "col_7": "Iterators are used to point memory addresses of STL containers",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 505,
    "col_2": "How many types of Iterators are provided by C++?",
    "col_3": 2,
    "col_4": 3,
    "col_5": 4,
    "col_6": 5,
    "col_7": 5,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 506,
    "col_2": "Which header file is used for Iterators?",
    "col_3": "<iterator>",
    "col_4": "<algorithm>",
    "col_5": "<iter>",
    "col_6": "<loopIter>",
    "col_7": "<iterator>",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 507,
    "col_2": "Which of the following is used for generic programming?",
    "col_3": "Virtual functions",
    "col_4": "Modules",
    "col_5": "Templates",
    "col_6": "Abstract Classes",
    "col_7": "Templates",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 508,
    "col_2": "Which of the following is correct about templates?",
    "col_3": "It is a type of compile time polymorphism",
    "col_4": "It allows the programmer to write one code for all data types",
    "col_5": "Helps in generic programming",
    "col_6": "All of the mentioned",
    "col_7": "All of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 509,
    "col_2": "Which of the following is used for generic programming?",
    "col_3": "Virtual functions",
    "col_4": "Modules",
    "col_5": "Templates",
    "col_6": "Abstract Classes",
    "col_7": "Templates",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 510,
    "col_2": "Which of the following is correct about templates?",
    "col_3": "It is a type of compile time polymorphism",
    "col_4": "It allows the programmer to write one code for all data types",
    "col_5": "Helps in generic programming",
    "col_6": "All of the mentioned",
    "col_7": "All of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 511,
    "col_2": "Which keyword is used to handle the expection?",
    "col_3": "try",
    "col_4": "throw",
    "col_5": "catch",
    "col_6": "handler",
    "col_7": "catch",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 512,
    "col_2": "Which is used to throw a exception?",
    "col_3": "throw",
    "col_4": "try",
    "col_5": "catch",
    "col_6": "handler",
    "col_7": "throw",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 513,
    "col_2": "What is the use of the 'finally' keyword?",
    "col_3": "It used to execute at the starting of the program",
    "col_4": "It will be executed at the end of the program even if the exception arised",
    "col_5": "It will be executed at the starting of the program even if the exception arised",
    "col_6": "It will be executed at the middle of the program even if the exception arised",
    "col_7": "It will be executed at the end of the program even if the exception arised",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 514,
    "col_2": "How do define the user-defined exceptions?",
    "col_3": "inheriting and overriding exception class functionality",
    "col_4": "overriding class functionality",
    "col_5": "inheriting class functionality",
    "col_6": "delting and adding class member",
    "col_7": "inheriting and overriding exception class functionality",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 515,
    "col_2": "Which exception is thrown by dynamic_cast?",
    "col_3": "bad_cast",
    "col_4": "bad_typeid",
    "col_5": "bad_exception",
    "col_6": "bad_alloc",
    "col_7": "bad_cast",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 516,
    "col_2": "How many types of exception handling are there in c++?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 2,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 517,
    "col_2": "How many runtime error messages associated with exception?",
    "col_3": 2,
    "col_4": 4,
    "col_5": 5,
    "col_6": "infinite",
    "col_7": 4,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 518,
    "col_2": "Which block should be placed after try block?",
    "col_3": "catch",
    "col_4": "throw",
    "col_5": "either catch or throw",
    "col_6": "handler",
    "col_7": "catch",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 519,
    "col_2": "Pick out the correct answer.",
    "col_3": "Exceptions are not suitable for critical points in code",
    "col_4": "Exception are suitable for critical points in code",
    "col_5": "Exceptions are used when postconditions of a function cannot be satisfied",
    "col_6": "Throw block should be placed after try block",
    "col_7": "Exceptions are not suitable for critical points in code",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 520,
    "col_2": "When exceptions are used?",
    "col_3": "To preserve the program",
    "col_4": "Exceptions are used when postconditions of a function cannot be satisfied",
    "col_5": "Exceptions are used when postconditions of a function can be satisfied",
    "col_6": "Exceptions are used when preconditions of a function cannot be satisfied",
    "col_7": "Exceptions are used when postconditions of a function can be satisfied",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 521,
    "col_2": "How many parameters does the throw expression can have?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 1,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 522,
    "col_2": "Where exception are handled?",
    "col_3": "inside the program",
    "col_4": "outside the regular code",
    "col_5": "both inside or outside",
    "col_6": "main program",
    "col_7": "outside the regular code",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 523,
    "col_2": "Which is used to check the error in the block?",
    "col_3": "try",
    "col_4": "throw",
    "col_5": "catch",
    "col_6": "handler",
    "col_7": "try",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 524,
    "col_2": "How to handle the exception in constructor?",
    "col_3": "We have to throw an exception",
    "col_4": "We have to return the exception",
    "col_5": "We have to throw an exception & return the exception",
    "col_6": "We have to catch an exception",
    "col_7": "We have to throw an exception",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 525,
    "col_2": "What should present when throwing a object?",
    "col_3": "constructor",
    "col_4": "copy-constructor",
    "col_5": "destructor",
    "col_6": "copy-destructor",
    "col_7": "copy-constructor",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 526,
    "col_2": "What can go wrong in resource management on c++?",
    "col_3": "Leakage",
    "col_4": "Exhaustion",
    "col_5": "Dangling",
    "col_6": "Exception",
    "col_7": "Exception",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 527,
    "col_2": "When do we call that resource is leaked?",
    "col_3": "Arise of compile time error",
    "col_4": "It cannot be accessed by any standard mean",
    "col_5": "Arise of runtime error",
    "col_6": "It can be accessed by any standard mean",
    "col_7": "It cannot be accessed by any standard mean",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 528,
    "col_2": "What kind of error can arise when there is a problem with memory?",
    "col_3": "Segmentation fault",
    "col_4": "Produce an error",
    "col_5": "Both Segmentation fault & Produce an error",
    "col_6": "runtime error",
    "col_7": "Segmentation fault",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 529,
    "col_2": "What is meant by garbage collection?",
    "col_3": "The form of manual memory management",
    "col_4": "The form of automatic memory management",
    "col_5": "Used to replace the variables",
    "col_6": "Used to delete the variables",
    "col_7": "The form of automatic memory management",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 530,
    "col_2": "What are the operators available in C++ for dynamic allocation and de-allocation of memories?",
    "col_3": "new",
    "col_4": "delete",
    "col_5": "compare",
    "col_6": "both new & delete",
    "col_7": "both new & delete",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 531,
    "col_2": "Which is used to solve the memory management problem in c++?",
    "col_3": "smart pointers",
    "col_4": "arrays",
    "col_5": "stack",
    "col_6": "queue",
    "col_7": "smart pointers",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 532,
    "col_2": "Which is used to handle the exceptions in c++?",
    "col_3": "catch handler",
    "col_4": "handler",
    "col_5": "exception handler",
    "col_6": "throw",
    "col_7": "exception handler",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 533,
    "col_2": "Which type of program is recommended to include in try block?",
    "col_3": "static memory allocation",
    "col_4": "dynamic memory allocation",
    "col_5": "const reference",
    "col_6": "pointer",
    "col_7": "dynamic memory allocation",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 534,
    "col_2": "Which statement is used to catch all types of exceptions?",
    "col_3": "catch()",
    "col_4": "catch(Test t)",
    "col_5": "catch(…)",
    "col_6": "catch(Test)",
    "col_7": "catch(…)",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 535,
    "col_2": "How to handle error in the destructor?",
    "col_3": "throwing",
    "col_4": "terminate",
    "col_5": "both throwing & terminate",
    "col_6": "try",
    "col_7": "terminate",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 536,
    "col_2": "What kind of exceptions are available in c++?",
    "col_3": "handled",
    "col_4": "unhandled",
    "col_5": "static",
    "col_6": "dynamic",
    "col_7": "unhandled",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 537,
    "col_2": "What is meant by exception specification?",
    "col_3": "A function is limited to throwing only a specified list of exceptions",
    "col_4": "A catch can catch all types of exceptions",
    "col_5": "A function can throw any type of exceptions",
    "col_6": "A try can catch all types of exceptions",
    "col_7": "A function is limited to throwing only a specified list of exceptions",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 538,
    "col_2": "Identify the correct statement about throw(type).",
    "col_3": "A function can throw any type of exceptions",
    "col_4": "A function can throw an exception of certain type only",
    "col_5": "A function can't throw any type of exception",
    "col_6": "A function can catch all types of exceptions",
    "col_7": "A function can throw an exception of certain type only",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 539,
    "col_2": "What will happen when a programs throws any other type of exception other than specified?",
    "col_3": "terminate",
    "col_4": "arise an error",
    "col_5": "run",
    "col_6": "throw",
    "col_7": "arise an error",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 540,
    "col_2": "What do you mean by \"No exception specification\"?",
    "col_3": "It throws nothing",
    "col_4": "It can throw anything",
    "col_5": "It can catch anything",
    "col_6": "It can try anything",
    "col_7": "It can throw anything",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 541,
    "col_2": "Which operations don't throw anything?",
    "col_3": "Operations which are reversible",
    "col_4": "Operations which are irreversible",
    "col_5": "Operations which are static",
    "col_6": "Operations which are dynamic",
    "col_7": "Operations which are irreversible",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 542,
    "col_2": "What will happen when we move to try block far away from catch block?",
    "col_3": "Reduces the amount of code in cache",
    "col_4": "Increases the amount of code in cache",
    "col_5": "Don't alter anything",
    "col_6": "Increases the amount of code",
    "col_7": "Reduces the amount of code in cache",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 543,
    "col_2": "What will happen if an exception that is thrown may cause a whole load of objects to go out of scope?",
    "col_3": "Terminate the program",
    "col_4": "Produce a runtime error",
    "col_5": "It will be added to the overhead",
    "col_6": "Compilation error",
    "col_7": "It will be added to the overhead",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 544,
    "col_2": "What operation can be performed by destructor?",
    "col_3": "Abort the program",
    "col_4": "Resource cleanup",
    "col_5": "Exit from the current block",
    "col_6": "Terminate the program",
    "col_7": "Resource cleanup",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 545,
    "col_2": "What is the main purpose of the constructor?",
    "col_3": "Begin the execution of class",
    "col_4": "Include the macros for the program",
    "col_5": "Establish the class invariant",
    "col_6": "Terminate the program",
    "col_7": "Establish the class invariant",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 546,
    "col_2": "Why is it expensive to use objects for the exception?",
    "col_3": "Exception object is created only if an error actually happens",
    "col_4": "Because of execution time",
    "col_5": "Memory space involved in creating an exception object",
    "col_6": "Because of time and space",
    "col_7": "Exception object is created only if an error actually happens",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 547,
    "col_2": "What is an exception in C++ program?",
    "col_3": "A problem that arises during the execution of a program",
    "col_4": "A problem that arises during compilation",
    "col_5": "Also known as the syntax error",
    "col_6": "Also known as semantic error",
    "col_7": "A problem that arises during the execution of a program",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 548,
    "col_2": "By default, what a program does when it detects an exception?",
    "col_3": "Continue running",
    "col_4": "Results in the termination of the program",
    "col_5": "Calls other functions of the program",
    "col_6": "Removes the exception and tells the programmer about an exception",
    "col_7": "Results in the termination of the program",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 549,
    "col_2": "Why do we need to handle exceptions?",
    "col_3": "To avoid unexpected behaviour of a program during run-time",
    "col_4": "To let compiler remove all exceptions by itself",
    "col_5": "To successfully compile the program",
    "col_6": "To get correct output",
    "col_7": "To avoid unexpected behaviour of a program during run-time",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 550,
    "col_2": "How Exception handling is implemented in the C++ program?",
    "col_3": "Using Exception keyword",
    "col_4": "Using try-catch block",
    "col_5": "Using Exception block",
    "col_6": "Using Error handling schedules",
    "col_7": "Using try-catch block",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 551,
    "col_2": "Which part of the try-catch block is always fully executed?",
    "col_3": "try part",
    "col_4": "catch part",
    "col_5": "finally part",
    "col_6": "throw part",
    "col_7": "finally part",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 552,
    "col_2": "Which of the following is an exception in C++?",
    "col_3": "Divide by zero",
    "col_4": "Semicolon not written",
    "col_5": "Variable not declared",
    "col_6": "An expression is wrongly written",
    "col_7": "Divide by zero",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 553,
    "col_2": "What is an error in C++?",
    "col_3": "Violation of syntactic and semantic rules of a languages",
    "col_4": "Missing of Semicolon",
    "col_5": "Missing of double quotes",
    "col_6": "Violation of program interface",
    "col_7": "Violation of syntactic and semantic rules of a languages",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 554,
    "col_2": "What is the difference between error and exception?",
    "col_3": "Both are the same",
    "col_4": "Errors can be handled at the run-time but the exceptions cannot",
    "col_5": "Exceptions can be handled at the run-time but the errors cannot",
    "col_6": "Both can be handled during run-time",
    "col_7": "Exceptions can be handled at the run-time but the errors cannot",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 555,
    "col_2": "What are the different types of exceptions?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 2,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 556,
    "col_2": "Which keyword is used to throw an exception?",
    "col_3": "try",
    "col_4": "throw",
    "col_5": "throws",
    "col_6": "except",
    "col_7": "throw",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 557,
    "col_2": "What is Re-throwing an exception means in C++?",
    "col_3": "An exception that is thrown again as it is not handled by that catching block",
    "col_4": "An exception that is caught twice",
    "col_5": "An exception that is not handled in one caught hence thrown again",
    "col_6": "All of the mentioned",
    "col_7": "All of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 558,
    "col_2": "Where should we place catch block of the derived class in a try-catch block?",
    "col_3": "Before the catch block of Base class",
    "col_4": "After the catch block of Base class",
    "col_5": "Anywhere in the sequence of catch blocks",
    "col_6": "After all the catch blocks",
    "col_7": "Before the catch block of Base class",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 559,
    "col_2": "What id the syntax for catching any type of exceptions?",
    "col_3": "catch(Exception e)",
    "col_4": "catch(…)",
    "col_5": "catch(Exception ALL)",
    "col_6": "catch(ALL)",
    "col_7": "catch(…)",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 560,
    "col_2": "Uncaught exception leads to ______________",
    "col_3": "termination of program",
    "col_4": "successful execution of programs",
    "col_5": "no effect on the program",
    "col_6": "execution of other functions of the program starts",
    "col_7": "termination of program",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 561,
    "col_2": "An uncaught handler returns to _______________",
    "col_3": "main function",
    "col_4": "its caller",
    "col_5": "its callee",
    "col_6": "waits there for some time",
    "col_7": "its callee",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 562,
    "col_2": "Header file used for exception handling in C++?",
    "col_3": "<cstdlib>",
    "col_4": "<string>",
    "col_5": "<handler>",
    "col_6": "<exception>",
    "col_7": "<exception>",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 563,
    "col_2": "The C++ code which causes abnormal termination/behaviour of a program should be written under _________ block.",
    "col_3": "try",
    "col_4": "catch",
    "col_5": "finally",
    "col_6": "throw",
    "col_7": "try",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 564,
    "col_2": "Exception handlers are declared with ____________ keyword.",
    "col_3": "try",
    "col_4": "catch",
    "col_5": "throw",
    "col_6": "finally",
    "col_7": "catch",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 565,
    "col_2": "In nested try-catch block, if the inner catch block gets executed, then______________",
    "col_3": "Program stops immediately",
    "col_4": "Outer catch block also executes",
    "col_5": "Compiler jumps to the outer catch block and executes remaining statements of the main() function",
    "col_6": "Compiler executes remaining statements of outer try-catch block and then the main() function",
    "col_7": "Compiler executes remaining statements of outer try-catch block and then the main() function",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 566,
    "col_2": "If inner catch block is unable to handle the exception thrown then__________",
    "col_3": "The compiler looks for the outer try-catch block",
    "col_4": "Program stops abnormally",
    "col_5": "The compiler will check for appropriate catch handler of the outer try block",
    "col_6": "The compiler will not check for appropriate catch handler of the outer try block",
    "col_7": "The compiler will check for appropriate catch handler of the outer try block",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 567,
    "col_2": "In nested try catch blocks, if both inner and outer catch blocks are unable to handle the exception thrown, then ______________",
    "col_3": "Compiler executes only main()",
    "col_4": "Compiler throws compile time errors about it",
    "col_5": "Program will run without any interrupt",
    "col_6": "Program will be termianted abnormally",
    "col_7": "Program will be termianted abnormally",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 568,
    "col_2": "Which function is invoked when an unhandled exception is thrown?",
    "col_3": "stop()",
    "col_4": "aborted()",
    "col_5": "terminate()",
    "col_6": "abandon()",
    "col_7": "terminate()",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 569,
    "col_2": "How one can restrict a function to throw particular exceptions only?",
    "col_3": "By defining multiple try-catch blocks inside a function",
    "col_4": "By defining a generic function within a try-catch block",
    "col_5": "By defining a function with throw clauses",
    "col_6": "Not allowed in C++",
    "col_7": "By defining a function with throw clauses",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 570,
    "col_2": "Which function is invoked when we try to throw an exception that is not supported by a function?",
    "col_3": "indeterminate()",
    "col_4": "unutilized()",
    "col_5": "unexpected()",
    "col_6": "unpredicted()",
    "col_7": "unexpected()",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 571,
    "col_2": "Return type of uncaught_exception() is________________",
    "col_3": "int",
    "col_4": "bool",
    "col_5": "char *",
    "col_6": "double",
    "col_7": "bool",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 572,
    "col_2": "Which alternative can replace the throw statement?",
    "col_3": "for",
    "col_4": "break",
    "col_5": "return",
    "col_6": "exit",
    "col_7": "return",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 573,
    "col_2": "What are the disadvantages if use return keyword to return error codes?",
    "col_3": "You have to handle all exceptional cases explicitly",
    "col_4": "Your code size increases dramatically",
    "col_5": "The code becomes more difficult to read",
    "col_6": "All of the mentioned",
    "col_7": "All of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 574,
    "col_2": "What is most suitable for returning the logical errors in the program?",
    "col_3": "Use constructor and destructor",
    "col_4": "Set a global error indicator",
    "col_5": "Use break keyword",
    "col_6": "Use final keyword",
    "col_7": "Set a global error indicator",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 575,
    "col_2": "What is the use of RAII in c++ programming?",
    "col_3": "Improve the exception safety",
    "col_4": "Terminate the program",
    "col_5": "Exit from the block",
    "col_6": "Crash the compiler",
    "col_7": "Improve the exception safety",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 576,
    "col_2": "How many levels are there in exception safety?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 3,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 577,
    "col_2": "Pick out the correct statement for error handling alternatives.",
    "col_3": "Terminate the program",
    "col_4": "Use the stack",
    "col_5": "Exit from the block",
    "col_6": "Use the queue",
    "col_7": "Use the stack",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 578,
    "col_2": "What will happen when an exception is not processed?",
    "col_3": "It will eat up a lot of memory and program size",
    "col_4": "Terminate the program",
    "col_5": "Crash the compiler",
    "col_6": "Displays proper output",
    "col_7": "It will eat up a lot of memory and program size",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 579,
    "col_2": "Which header file is used to declare the standard exception?",
    "col_3": "#include<exception>",
    "col_4": "#include<except>",
    "col_5": "#include<error>",
    "col_6": "#include<exce>",
    "col_7": "#include<exception>",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 580,
    "col_2": "Where are standard exception classes grouped?",
    "col_3": "namespace std",
    "col_4": "error",
    "col_5": "catch",
    "col_6": "final",
    "col_7": "namespace std",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 581,
    "col_2": "How many types of standard exception are there in c++?",
    "col_3": 9,
    "col_4": 5,
    "col_5": 6,
    "col_6": 7,
    "col_7": 9,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 582,
    "col_2": "Which of the following is best to include under try block?",
    "col_3": "static values",
    "col_4": "const values",
    "col_5": "dynamic allocations",
    "col_6": "default values",
    "col_7": "dynamic allocations",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 583,
    "col_2": "What are the predefined exceptions in c++?",
    "col_3": "Memory allocation errors",
    "col_4": "I/O errors",
    "col_5": "Both Memory allocation errors & I/O errors",
    "col_6": "static errors",
    "col_7": "Both Memory allocation errors & I/O errors",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 584,
    "col_2": "What will happen when introduce the interface of classes in a run-time polymorphic hierarchy?",
    "col_3": "Separation of interface from implementation",
    "col_4": "Merging of interface from implementation",
    "col_5": "Separation of interface from debugging",
    "col_6": "Merging of interface from debugging",
    "col_7": "Separation of interface from implementation",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 585,
    "col_2": "Which classes are called as mixin?",
    "col_3": "Represent a secondary design",
    "col_4": "Classes express functionality which represents responsibilities",
    "col_5": "Standard logging stream",
    "col_6": "Represent a priary design",
    "col_7": "Classes express functionality which represents responsibilities",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 586,
    "col_2": "What is the use of clog?",
    "col_3": "Standard logging stream",
    "col_4": "Error stream",
    "col_5": "Input stream",
    "col_6": "output stream",
    "col_7": "Standard logging stream",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 587,
    "col_2": "How many types of guarantees are there in exception class can have?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 3,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 588,
    "col_2": "Which operator is used to create the user-defined streams in c++?",
    "col_3": ">>",
    "col_4": "<<",
    "col_5": "&",
    "col_6": "Both >> & <<",
    "col_7": "Both >> & <<",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 589,
    "col_2": "What does the cerr represent?",
    "col_3": "Standard error stream",
    "col_4": "Standard logging stream",
    "col_5": "Input stream",
    "col_6": "Output stream",
    "col_7": "Standard error stream",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 590,
    "col_2": "What is meant by multiple inheritance?",
    "col_3": "Deriving a base class from derived class",
    "col_4": "Deriving a derived class from base class",
    "col_5": "Deriving a derived class from more than one base class",
    "col_6": "Deriving a derived base class",
    "col_7": "Deriving a derived class from more than one base class",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 591,
    "col_2": "Which symbol is used to create multiple inheritances?",
    "col_3": "Dot",
    "col_4": "Comma",
    "col_5": "Dollar",
    "col_6": "star",
    "col_7": "Comma",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 592,
    "col_2": "Which of the following advantages we lose by using multiple inheritances?",
    "col_3": "Dynamic binding",
    "col_4": "Polymorphism",
    "col_5": "Both Dynamic binding & Polymorphism",
    "col_6": "Constructor",
    "col_7": "Both Dynamic binding & Polymorphism",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 593,
    "col_2": "Which design patterns benefit from the multiple inheritances?",
    "col_3": "Adapter and observer pattern",
    "col_4": "Code pattern",
    "col_5": "Glue pattern",
    "col_6": "Star pattern",
    "col_7": "Adapter and observer pattern",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 594,
    "col_2": "What are the things are inherited from the base class?",
    "col_3": "Constructor and its destructor",
    "col_4": "Operator=() members",
    "col_5": "Friends",
    "col_6": "All of the mentioned",
    "col_7": "All of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 595,
    "col_2": "What is Inheritance in C++?",
    "col_3": "Wrapping of data into a single class",
    "col_4": "Deriving new classes from existing classes",
    "col_5": "Overloading of classes",
    "col_6": "Classes with same names",
    "col_7": "Deriving new classes from existing classes",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 596,
    "col_2": "How many specifiers are used to derive a class?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 3,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 597,
    "col_2": "Which specifier makes all the data members and functions of base class inaccessible by the derived class?",
    "col_3": "private",
    "col_4": "protected",
    "col_5": "public",
    "col_6": "both private and protected",
    "col_7": "private",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 598,
    "col_2": "If a class is derived privately from a base class then ______________________________",
    "col_3": "no members of the base class is inherited",
    "col_4": "all members are accessible by the derived class",
    "col_5": "all the members are inherited by the class but are hidden and cannot be accessible",
    "col_6": "no derivation of the class gives an error",
    "col_7": "all the members are inherited by the class but are hidden and cannot be accessible",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 599,
    "col_2": "What is a virtual function in C++?",
    "col_3": "Any member function of a class",
    "col_4": "All functions that are derived from the base class",
    "col_5": "All the members that are accessing base class data members",
    "col_6": "All the functions which are declared in the base class and is re-defined/overridden by the derived class",
    "col_7": "All the functions which are declared in the base class and is re-defined/overridden by the derived class",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 600,
    "col_2": "Which is the correct syntax of declaring a virtual function?",
    "col_3": "virtual int func();",
    "col_4": "virtual int func(){};",
    "col_5": "inline virtual func();",
    "col_6": "inline virtual func(){};",
    "col_7": "virtual int func();",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 601,
    "col_2": "Which statement is incorrect about virtual function.",
    "col_3": "They are used to achieve runtime polymorphism",
    "col_4": "They are used to hide objects",
    "col_5": "Each virtual function declaration starts with the virtual keyword",
    "col_6": "All of the mentioned",
    "col_7": "They are used to hide objects",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 602,
    "col_2": "The concept of deciding which function to invoke during runtime is called ______________________",
    "col_3": "late binding",
    "col_4": "dynamic linkage",
    "col_5": "static binding",
    "col_6": "both late binding and dynamic linkage",
    "col_7": "both late binding and dynamic linkage",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 603,
    "col_2": "What is a pure virtual function?",
    "col_3": "A virtual function defined inside the base class",
    "col_4": "A virtual function that has no definition relative to the base class",
    "col_5": "A virtual function that is defined inside the derived class",
    "col_6": "Any function that is made virtual",
    "col_7": "A virtual function that has no definition relative to the base class",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 604,
    "col_2": "What is the order of Constructors call when the object of derived class B is declared, provided class B is derived from class A?",
    "col_3": "Constructor of A followed by B",
    "col_4": "Constructor of B followed by A",
    "col_5": "Constructor of A only",
    "col_6": "Constructor of B only",
    "col_7": "Constructor of A followed by B",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 605,
    "col_2": "What is the order of Destructors call when the object of derived class B is declared, provided class B is derived from class A?",
    "col_3": "Destructor of A followed by B",
    "col_4": "Destructor of B followed by A",
    "col_5": "Destructor of A only",
    "col_6": "Destructor of B only",
    "col_7": "Destructor of B followed by A",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 606,
    "col_2": "Virtual functions in C++ tells the compiler to perform ______________________ on such functions.",
    "col_3": "static binding",
    "col_4": "late binding",
    "col_5": "compile time binding",
    "col_6": "no binding",
    "col_7": "late binding",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 607,
    "col_2": "Which concept of OOPs is shown by Virtual Functions?",
    "col_3": "Inheritance",
    "col_4": "Encapsulation",
    "col_5": "Polymorphism",
    "col_6": "Abstraction",
    "col_7": "Polymorphism",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 608,
    "col_2": "Pick the correct statement.",
    "col_3": "Virtual function can have different names in the base and derived class",
    "col_4": "Virtual function cannot be applied in Multiple Inheritance classes",
    "col_5": "Virtual function are different in definitions only",
    "col_6": "Virtual function does early binding",
    "col_7": "Virtual function are different in definitions only",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 609,
    "col_2": "Which access specifier is used where one wants data members to be accessed by other classes but not from outside objects?",
    "col_3": "private",
    "col_4": "protected",
    "col_5": "public",
    "col_6": "both protected and public",
    "col_7": "protected",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 610,
    "col_2": "Which of the following describes the protected access specifier?",
    "col_3": "The variable is visible only outside inside the block",
    "col_4": "The variable is visible everywhere",
    "col_5": "The variable is visible to its block and to it's derived class",
    "col_6": "The variable is not visible to its block",
    "col_7": "The variable is visible to its block and to it's derived class",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 611,
    "col_2": "To which of the following access specifiers are applicable?",
    "col_3": "Member data",
    "col_4": "Functions",
    "col_5": "Both Member data & Functions",
    "col_6": "Protected members",
    "col_7": "Both Member data & Functions",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 612,
    "col_2": "Members of which access specifiers are not inherited?",
    "col_3": "Public",
    "col_4": "Protected",
    "col_5": "Private",
    "col_6": "None of the mentioned",
    "col_7": "None of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 613,
    "col_2": "What is the importance of mutable keyword?",
    "col_3": "It allows the data member to change within a const member function",
    "col_4": "It will not allow the data member to change within a const member function",
    "col_5": "It will copy the values of the variable",
    "col_6": "It allows the data member to change outside a const member function",
    "col_7": "It allows the data member to change within a const member function",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 614,
    "col_2": "What is the Run-Time Type Information?",
    "col_3": "Information about an object's data type at runtime",
    "col_4": "Information about the variables",
    "col_5": "Information about the given block",
    "col_6": "Information about the functions",
    "col_7": "Information about an object's data type at runtime",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 615,
    "col_2": "Which operators are part of RTTI?",
    "col_3": "dynamic_cast()",
    "col_4": "typeid",
    "col_5": "both dynamic_cast<> & typeid",
    "col_6": "dynamic_cast[]",
    "col_7": "both dynamic_cast<> & typeid",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 616,
    "col_2": "To which type of class, We can apply RTTI?",
    "col_3": "Encapsulation",
    "col_4": "Polymorphic",
    "col_5": "Derived",
    "col_6": "Static",
    "col_7": "Polymorphic",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 617,
    "col_2": "What is meant by type_info?",
    "col_3": "Used to hold the type information returned by the typeid operator",
    "col_4": "Used to hold the type information returned by the dynamic_cast",
    "col_5": "Used to hold the type information returned by the static_cast",
    "col_6": "Used to hold the type information returned by the static_id",
    "col_7": "Used to hold the type information returned by the typeid operator",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 618,
    "col_2": "At which time does the static_cast can be applied?",
    "col_3": "Compile-time construct",
    "col_4": "Runtime construct",
    "col_5": "Both Compile-time & Runtime construct",
    "col_6": "Runtime deconstruct",
    "col_7": "Compile-time construct",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 619,
    "col_2": "Which is referred by pointers to member?",
    "col_3": "Static members of class objects",
    "col_4": "Non-static members of class objects",
    "col_5": "Referring to whole class",
    "col_6": "Dynamic members of class objects",
    "col_7": "Non-static members of class objects",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 620,
    "col_2": "What should be used to point to a static class member?",
    "col_3": "Smart pointer",
    "col_4": "Dynamic pointer",
    "col_5": "Normal pointer",
    "col_6": "Static pointer",
    "col_7": "Normal pointer",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 621,
    "col_2": "Which operator is used in pointer to member function?",
    "col_3": ".*",
    "col_4": "->*",
    "col_5": "Both .* & ->*",
    "col_6": "$*",
    "col_7": "Both .* & ->*",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 622,
    "col_2": "Which is the best design choice for using pointer to member function?",
    "col_3": "Interface",
    "col_4": "Class",
    "col_5": "Structure",
    "col_6": "Block",
    "col_7": "Interface",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 623,
    "col_2": "What is the operation for .*?",
    "col_3": "It combines the first operand and the second operand",
    "col_4": "It separates the first operand and the second operand",
    "col_5": "It reduces the data size",
    "col_6": "It combines the first operand and the second operand and terminates third operand",
    "col_7": "It combines the first operand and the second operand",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 624,
    "col_2": "Which is used to allocate and deallocate storage for objects during the execution?",
    "col_3": "Stack",
    "col_4": "Heap",
    "col_5": "Freestore",
    "col_6": "Queue",
    "col_7": "Freestore",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 625,
    "col_2": "Which operators are used in the free store?",
    "col_3": "new",
    "col_4": "delete",
    "col_5": "both new & delete",
    "col_6": "terminate",
    "col_7": "both new & delete",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 626,
    "col_2": "What type of class member is operator new?",
    "col_3": "static",
    "col_4": "dynamic",
    "col_5": "const",
    "col_6": "smart",
    "col_7": "static",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 627,
    "col_2": "What must be an operand of operator delete?",
    "col_3": "Pointer",
    "col_4": "Array",
    "col_5": "Stack",
    "col_6": "Queue",
    "col_7": "Pointer",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 628,
    "col_2": "How can object be allocated outside the object lifetime?",
    "col_3": "int",
    "col_4": "float",
    "col_5": "void*",
    "col_6": "char$",
    "col_7": "void*",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 629,
    "col_2": "Pick out the wrong header file about strings.",
    "col_3": "<string>",
    "col_4": "<regex>",
    "col_5": "<ios>",
    "col_6": "<reg>",
    "col_7": "<ios>",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 630,
    "col_2": "Which is best for coding the standard library for c++?",
    "col_3": "no trailing underscores on names",
    "col_4": "complex objects are returned by value",
    "col_5": "have a member-swap()",
    "col_6": "all of the mentioned",
    "col_7": "all of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 631,
    "col_2": "What is meant by vector in the container library contains?",
    "col_3": "It is a sequence container that encapsulates dynamic size arrays",
    "col_4": "It is a sequence container that encapsulates static size arrays",
    "col_5": "It manages the memory",
    "col_6": "It manages the length and size",
    "col_7": "It is a sequence container that encapsulates dynamic size arrays",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 632,
    "col_2": "Pick out the wrong header file.",
    "col_3": "<algorithm>",
    "col_4": "<containers>",
    "col_5": "<iterators>",
    "col_6": "<process>",
    "col_7": "<process>",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 633,
    "col_2": "What is meant by standard c++ library?",
    "col_3": "It is the collection of class definitions for standard data structures and a collection of algorithms",
    "col_4": "It is a header file",
    "col_5": "Collection of algorithms",
    "col_6": "Step by step process",
    "col_7": "It is the collection of class definitions for standard data structures and a collection of algorithms",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 634,
    "col_2": "Pick out parameter for rehash method in unordered_set in c++?",
    "col_3": "count",
    "col_4": "size",
    "col_5": "hash",
    "col_6": "type",
    "col_7": "count",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 635,
    "col_2": "What is the use of <exception> header",
    "col_3": "Contains the standard exception files",
    "col_4": "Contains the standard library files",
    "col_5": "It is used to arise an exception in the program",
    "col_6": "Reduce the memory size",
    "col_7": "Contains the standard exception files",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 636,
    "col_2": "How many sets of requirements are need in designing a container?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 3,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 637,
    "col_2": "Which interface in the container is required for storage management?",
    "col_3": "Memory management",
    "col_4": "Allocator interface",
    "col_5": "Memory interface",
    "col_6": "Storage interface",
    "col_7": "Allocator interface",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 638,
    "col_2": "Which is present in the basic interface of the allocator interface?",
    "col_3": "Set of typedefs",
    "col_4": "A pair of allocation functions",
    "col_5": "allocate()",
    "col_6": "All of the mentioned",
    "col_7": "All of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 639,
    "col_2": "Which container provides random access iterators?",
    "col_3": "vector",
    "col_4": "deque",
    "col_5": "sort",
    "col_6": "both vector & deque",
    "col_7": "both vector & deque",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 640,
    "col_2": "Which is used for manually writing lookup table?",
    "col_3": "std:map",
    "col_4": "std:lookup",
    "col_5": "std:find",
    "col_6": "std:lock",
    "col_7": "std:map",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 641,
    "col_2": "How can the member functions in the container be accessed?",
    "col_3": "Iterator",
    "col_4": "Indirect",
    "col_5": "Both Iterator & Indirect",
    "col_6": "Vector",
    "col_7": "Iterator",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 642,
    "col_2": "Which of the following type does the container should define?",
    "col_3": "Iterator type",
    "col_4": "Vector type",
    "col_5": "Storage type",
    "col_6": "Memory type",
    "col_7": "Iterator type",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 643,
    "col_2": "Which are the parameters for the content of the buffer?",
    "col_3": "start",
    "col_4": "finish",
    "col_5": "both start & finish",
    "col_6": "pause",
    "col_7": "both start & finish",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 644,
    "col_2": "What do vectors represent?",
    "col_3": "Static arrays",
    "col_4": "Dynamic arrays",
    "col_5": "Stack",
    "col_6": "Queue",
    "col_7": "Dynamic arrays",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 645,
    "col_2": "In which type of storage location are the vector members stored?",
    "col_3": "Contiguous storage locations",
    "col_4": "Non-contiguous storage locations",
    "col_5": "Contiguous & Non-contiguous storage locations",
    "col_6": "Memory storage locations",
    "col_7": "Contiguous storage locations",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 646,
    "col_2": "How many vector container properties are there in c++?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 3,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 647,
    "col_2": "Pick out the correct statement about vector.",
    "col_3": "vector<int> values (5)",
    "col_4": "vector values (5)",
    "col_5": "vector<int> (5)",
    "col_6": "vector<5>",
    "col_7": "vector<int> values (5)",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 648,
    "col_2": "Which is optional in the declaration of vector?",
    "col_3": "Type",
    "col_4": "Name",
    "col_5": "Vector",
    "col_6": "Number_of_elements",
    "col_7": "Number_of_elements",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 649,
    "col_2": "How many items are there in sequence container?",
    "col_3": 2,
    "col_4": 3,
    "col_5": 4,
    "col_6": 5,
    "col_7": 5,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 650,
    "col_2": "Which of the following class template are based on arrays?",
    "col_3": "vector",
    "col_4": "list",
    "col_5": "dequeue",
    "col_6": "both vector & dequeue",
    "col_7": "both vector & dequeue",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 651,
    "col_2": "Which of the following will return the new element at the end of container?",
    "col_3": "front",
    "col_4": "back",
    "col_5": "push_back",
    "col_6": "pop_back",
    "col_7": "back",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 652,
    "col_2": "How the list containers are implemented?",
    "col_3": "Using Double linked list",
    "col_4": "Using Single linked list",
    "col_5": "Using Single & Double linked list",
    "col_6": "Using linear linked list",
    "col_7": "Using Double linked list",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 653,
    "col_2": "Which of the following does not support any insertion or deletion?",
    "col_3": "Array",
    "col_4": "Vector",
    "col_5": "Dequeue",
    "col_6": "List",
    "col_7": "Array",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 654,
    "col_2": "What do container adapter provide to interface?",
    "col_3": "Restricted interface",
    "col_4": "More interface",
    "col_5": "No interface",
    "col_6": "Memory interface",
    "col_7": "Restricted interface",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 655,
    "col_2": "What does the sequence adaptor provide?",
    "col_3": "Insertion",
    "col_4": "Deletion",
    "col_5": "Interface to sequence container",
    "col_6": "Insertion & Deletion",
    "col_7": "Interface to sequence container",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 656,
    "col_2": "Which are presented in the container adaptors?",
    "col_3": "stack",
    "col_4": "queue",
    "col_5": "priority_queue",
    "col_6": "all of the mentioned",
    "col_7": "all of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 657,
    "col_2": "In which context does the stack operates?",
    "col_3": "FIFO",
    "col_4": "LIFO",
    "col_5": "Both FIFO & LIFO",
    "col_6": "LIFI",
    "col_7": "LIFO",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 658,
    "col_2": "Which operator is used in priority queue?",
    "col_3": "operator<",
    "col_4": "operator>",
    "col_5": "operator)",
    "col_6": "operator!",
    "col_7": "operator<",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 659,
    "col_2": "What do associate containers implement?",
    "col_3": "Arrays",
    "col_4": "Associative arrays",
    "col_5": "Functional Arrays",
    "col_6": "Static arrays",
    "col_7": "Associative arrays",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 660,
    "col_2": "By using which of the following the elements in the associate container can be efficiently accessed?",
    "col_3": "Key",
    "col_4": "Position",
    "col_5": "Both Key & Position",
    "col_6": "Value",
    "col_7": "Key",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 661,
    "col_2": "How many items are presented in the associate container?",
    "col_3": 2,
    "col_4": 3,
    "col_5": 4,
    "col_6": 5,
    "col_7": 4,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 662,
    "col_2": "How many instances are allowed by map and set while inserting an element into container?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": "Multiple",
    "col_7": 1,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 663,
    "col_2": "What do maps and sets support?",
    "col_3": "Single directional iterators",
    "col_4": "Bi-directional iterators",
    "col_5": "Single & Bi-directional directional iterators",
    "col_6": "functional iterators",
    "col_7": "Bi-directional iterators",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 664,
    "col_2": "What kind of library is Standard Template Library?",
    "col_3": "Polymorphic",
    "col_4": "Generic",
    "col_5": "Both Polymorphic & Generic",
    "col_6": "Virtual",
    "col_7": "Generic",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 665,
    "col_2": "To what type of object does the container can be instantiated?",
    "col_3": "int",
    "col_4": "float",
    "col_5": "double",
    "col_6": "any type of object",
    "col_7": "any type of object",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 666,
    "col_2": "What type of class template is list?",
    "col_3": "Class-based",
    "col_4": "Node-based",
    "col_5": "Method-based",
    "col_6": "size-based",
    "col_7": "Node-based",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 667,
    "col_2": "What type of access does deque and vector provide?",
    "col_3": "Linear access",
    "col_4": "Parallel access",
    "col_5": "Random access",
    "col_6": "Memory access",
    "col_7": "Random access",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 668,
    "col_2": "Where does the vector add the item?",
    "col_3": "End",
    "col_4": "Insert",
    "col_5": "Middle",
    "col_6": "Start",
    "col_7": "End",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 669,
    "col_2": "Which are not full container classes in c++?",
    "col_3": "Sequence container",
    "col_4": "Associative container",
    "col_5": "Container adaptor",
    "col_6": "iterative container",
    "col_7": "Container adaptor",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 670,
    "col_2": "What is the lifetime of the element in container?",
    "col_3": "Whole program",
    "col_4": "Outside the block",
    "col_5": "Everywhere",
    "col_6": "Only on that container",
    "col_7": "Only on that container",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 671,
    "col_2": "What do all STL containers define?",
    "col_3": "Iterator types",
    "col_4": "Begin methods",
    "col_5": "End methods",
    "col_6": "All of the mentioned",
    "col_7": "All of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 672,
    "col_2": "What do we return if we use simple array on a internal container?",
    "col_3": "Methods",
    "col_4": "Pointers",
    "col_5": "Objects",
    "col_6": "Values",
    "col_7": "Pointers",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 673,
    "col_2": "What is mandatory for designing a new container?",
    "col_3": "Classes",
    "col_4": "Iterators",
    "col_5": "Container",
    "col_6": "Variables",
    "col_7": "Iterators",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 674,
    "col_2": "What are the design requirements for building a container from the sratch?",
    "col_3": "Container interface requirements",
    "col_4": "Allocator interface requirements",
    "col_5": "Iterator requirements",
    "col_6": "All of the mentioned",
    "col_7": "All of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 675,
    "col_2": "How many iterators are needed for the defining a new container?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 3,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 676,
    "col_2": "What is the use of the allocator interface in the user-defined container?",
    "col_3": "Storage management",
    "col_4": "Memory management",
    "col_5": "Storage & Memory management",
    "col_6": "Iterator management",
    "col_7": "Storage management",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 677,
    "col_2": "How many types of container classes are there in c++?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": "As many as possible",
    "col_7": 2,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 678,
    "col_2": "What is the name of the container which contains group of multiple objects?",
    "col_3": "Heterogeneous container",
    "col_4": "Homogeneous container",
    "col_5": "Both Homogeneous & Heterogeneous container",
    "col_6": "Sequence container",
    "col_7": "Heterogeneous container",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 679,
    "col_2": "What is sequence container arrays?",
    "col_3": "C-like arrays",
    "col_4": "Template class sequence container, alternative for C-like arrays",
    "col_5": "Collection of data of the same type",
    "col_6": "Collection of objects",
    "col_7": "Template class sequence container, alternative for C-like arrays",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 680,
    "col_2": "Pick the correct statement.",
    "col_3": "Sequence Container arrays know (somehow stores within) its size whereas C-like arrays do not",
    "col_4": "Sequence Container arrays have no advantage over C-like arrays",
    "col_5": "Sequence Container arrays are same as C-like arrays",
    "col_6": "Sequence Container arrays are also present in C",
    "col_7": "Sequence Container arrays know (somehow stores within) its size whereas C-like arrays do not",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 681,
    "col_2": "Which of the following is/are advantage(s) of Sequence Container arrays over C-like arrays?",
    "col_3": "Sequence Container arrays store its size within itself whereas C-like arrays do not",
    "col_4": "Sequence Container arrays are more efficient",
    "col_5": "Sequence Container arrays have no array decay problem whereas C-like arrays do have",
    "col_6": "All of the mentioned",
    "col_7": "All of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 682,
    "col_2": "Which of the follwoing function(s) of Array classes are similar to [] operator?",
    "col_3": "at()",
    "col_4": "get()",
    "col_5": "both at() and get()",
    "col_6": "front()",
    "col_7": "both at() and get()",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 683,
    "col_2": "How many different ways are there to access an element of array classes at the ith position?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 3,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 684,
    "col_2": "What header file is included to use array classes?",
    "col_3": "<array>",
    "col_4": "<Array>",
    "col_5": "<algorithm>",
    "col_6": "<ARRAY>",
    "col_7": "<array>",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 685,
    "col_2": "What is the correct syntax of declaring an array class?",
    "col_3": "array<type> arr;",
    "col_4": "array<type,size> arr;",
    "col_5": "Array<type> arr;",
    "col_6": "Array<type,size> arr;",
    "col_7": "array<type,size> arr;",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 686,
    "col_2": "What is the syntax of printing the first element of an array Arr using get() function?",
    "col_3": "Arr.get(0)",
    "col_4": "get<0>(Arr)",
    "col_5": "Arr.get[0]",
    "col_6": "get<0>[Arr]",
    "col_7": "get<0>(Arr)",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 687,
    "col_2": "Which header file is required to use get() function?",
    "col_3": "<array>",
    "col_4": "<tuple>",
    "col_5": "<Array>",
    "col_6": "<access>",
    "col_7": "<tuple>",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 688,
    "col_2": "What is the difference between get() and at()?",
    "col_3": "at() is available under <array> header file whereas get() is available under <tuple> header file",
    "col_4": "at() is a member function of array class whereas get() is not",
    "col_5": "get() takes array class as a parameter whereas at() takes a constant integer(i.e. index) as a parameter",
    "col_6": "all of the mentioned",
    "col_7": "all of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 689,
    "col_2": "Which function is used to access the first element of an array class?",
    "col_3": "front()",
    "col_4": "start()",
    "col_5": "back()",
    "col_6": "first()",
    "col_7": "front()",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 690,
    "col_2": "Which function is used to access the last element of an array class?",
    "col_3": "end()",
    "col_4": "start()",
    "col_5": "back()",
    "col_6": "last()",
    "col_7": "back()",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 691,
    "col_2": "Which of the following function(s) is/are used to get the size of the array class?",
    "col_3": "size()",
    "col_4": "max_size()",
    "col_5": "both size() and max_size()",
    "col_6": "get_size()",
    "col_7": "both size() and max_size()",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 692,
    "col_2": "What is the use of swap() function in array class?",
    "col_3": "Swaps two elements of an array given elements",
    "col_4": "Swaps two arrays",
    "col_5": "Swaps two elements given indices of elements",
    "col_6": "Swaps same elements of the array if required",
    "col_7": "Swaps two arrays",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 693,
    "col_2": "What is the syntax of swap()?",
    "col_3": "swap(arr1, arr2);",
    "col_4": "arr1.swap(arr2);",
    "col_5": "swap<int, int>(arr1, arr2);",
    "col_6": "swap[arr1, arr2];",
    "col_7": "arr1.swap(arr2);",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 694,
    "col_2": "What is the use of empty() function in array classes?",
    "col_3": "To check whether the size of an array is zero or not",
    "col_4": "To check whether an array is empty or not",
    "col_5": "To check how many elements are there in the array",
    "col_6": "To check whether an array contains negative elements or not",
    "col_7": "To check whether the size of an array is zero or not",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 695,
    "col_2": "What is the use of fill() function in array class?",
    "col_3": "To fill an array with a given single value",
    "col_4": "To delete all the elements that are equal to the given value",
    "col_5": "To replace all the elements of the array which are equal to the given value",
    "col_6": "To check whether given element fills the array or not",
    "col_7": "To fill an array with a given single value",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 696,
    "col_2": "What are the vectors?",
    "col_3": "Arrays with dynamic size",
    "col_4": "Arrays with different types of elements",
    "col_5": "Same as array classes",
    "col_6": "Arrays with static size but use template classes",
    "col_7": "Arrays with dynamic size",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 697,
    "col_2": "Pick the correct statement.",
    "col_3": "Vectors have dynamic size whereas Array classes have a static size",
    "col_4": "Both vectors and Array classes have a dynamic size",
    "col_5": "Both vectors and Array classes have a static size",
    "col_6": "Vectors have static size whereas Array classes have a dynamic size",
    "col_7": "Vectors have dynamic size whereas Array classes have a static size",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 698,
    "col_2": "Pick the incorrect statement.",
    "col_3": "Vectors have a dynamic size",
    "col_4": "Vectors are placed in contiguous storage",
    "col_5": "Insertion in vectors always takes constant time",
    "col_6": "Vectors insert the element at the end",
    "col_7": "Insertion in vectors always takes constant time",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 699,
    "col_2": "Which of the following header file is needed to use vectors in your program?",
    "col_3": "<array>",
    "col_4": "<vector>",
    "col_5": "<containers>",
    "col_6": "<stdio>",
    "col_7": "<vector>",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 700,
    "col_2": "Which of the following(s) can be used to access the first element of a vector v?",
    "col_3": "v.begin()",
    "col_4": "v.cbegin()",
    "col_5": "v[0]",
    "col_6": "all of the mentioned",
    "col_7": "all of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 701,
    "col_2": "Which of the following(s) can be used to access the last element of a vector v?",
    "col_3": "v.end()",
    "col_4": "v.cend()",
    "col_5": "both v.end() and v.cend()",
    "col_6": "vectors do not have a function to access the last element",
    "col_7": "vectors do not have a function to access the last element",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 702,
    "col_2": "What is the difference between begin() and cbegin() in vectors?",
    "col_3": "both are same",
    "col_4": "begin() returns iterator to first element and cbegin() returns iterator to last element",
    "col_5": "begin() returns an iterator to first element whereas cbegin() returns constant iterator to first element",
    "col_6": "begin() returns returns first element cbegin() returns void",
    "col_7": "begin() returns an iterator to first element whereas cbegin() returns constant iterator to first element",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 703,
    "col_2": "What is the difference between begin() and rbegin()?",
    "col_3": "both are the same",
    "col_4": "begin() returns an iterator to the first element and rbegin() returns an iterator to an element kept at the end of the vector",
    "col_5": "begin() returns an iterator to first element whereas rbegin() returns constant iterator to first element",
    "col_6": "begin() returns returns first element rbegin() returns void",
    "col_7": "begin() returns an iterator to the first element and rbegin() returns an iterator to an element kept at the end of the vector",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 704,
    "col_2": "Which is the following is syntactically correct for vector<int> v?",
    "col_3": "vector <int> :: const_iterator itr = v.rbegin();",
    "col_4": "vector <int> :: reverse_iterator itr = v.begin();",
    "col_5": "vector <int> :: iterator itr = v.begin();",
    "col_6": "vector <int> :: iterator itr = v.cbegin();",
    "col_7": "vector <int> :: iterator itr = v.begin();",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 705,
    "col_2": "Which of the following function is used to get the actual number of elements stored in vector?",
    "col_3": "v.size()",
    "col_4": "v.capacity()",
    "col_5": "v.max_size()",
    "col_6": "v.no_of_elements()",
    "col_7": "v.size()",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 706,
    "col_2": "Which function is used to get the total capacity of a vector?",
    "col_3": "v.size()",
    "col_4": "v.capacity()",
    "col_5": "v.max_size()",
    "col_6": "v.no_of_elements()",
    "col_7": "v.capacity()",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 707,
    "col_2": "How the size of a vector increases once it is full?",
    "col_3": "Vector increases its capacity one by one",
    "col_4": "Vector doubles its capacity after it is full",
    "col_5": "Vector increases its capacity by half of its previous size",
    "col_6": "Vector increases its capacity by a constant factor",
    "col_7": "Vector doubles its capacity after it is full",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 708,
    "col_2": "Which function is used to check whether the vector is empty or not?",
    "col_3": "empty()",
    "col_4": "isempty()",
    "col_5": "haveElements()",
    "col_6": "none()",
    "col_7": "empty()",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 709,
    "col_2": "How many list sequence containers are provided by STL?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 2,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 710,
    "col_2": "Which type of list a Forward_list sequence container implements?",
    "col_3": "Singly Linked List",
    "col_4": "Doubly Linked List",
    "col_5": "Both type of list",
    "col_6": "A simple sequence of array",
    "col_7": "Singly Linked List",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 711,
    "col_2": "Which type of list a List sequence container implements?",
    "col_3": "Singly Linked List",
    "col_4": "Doubly Linked List",
    "col_5": "Both type of list",
    "col_6": "A simple sequence of array",
    "col_7": "Doubly Linked List",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 712,
    "col_2": "Which of the following header file is required for forwawrd_list?",
    "col_3": "<forward_list>",
    "col_4": "<list>",
    "col_5": "<f_list>",
    "col_6": "<Forward_List>",
    "col_7": "<forward_list>",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 713,
    "col_2": "Which of the following(s) is/are the correct way of assigning values to a forward_list f?",
    "col_3": "f.assign({1,2,3,4,5})",
    "col_4": "f.assign(10,5)",
    "col_5": "both f.assign({1,2,3,4,5}) and f.assign(10,5)",
    "col_6": "f.assign(1,1,1,1)",
    "col_7": "both f.assign({1,2,3,4,5}) and f.assign(10,5)",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 714,
    "col_2": "How the list differs from vectors?",
    "col_3": "Vector is contiguous whereas List is non-contiguous",
    "col_4": "Insertion in the list takes constant time whereas it is not constant in vectors",
    "col_5": "There is no capacity defined for list",
    "col_6": "All of the mentioned",
    "col_7": "All of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 715,
    "col_2": "What is the syntax of declaraing a forward_list?",
    "col_3": "forward_list f;",
    "col_4": "forward_list<type> f;",
    "col_5": "forward_list f<type>;",
    "col_6": "forward_list<type,size> f;",
    "col_7": "forward_list<type> f;",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 716,
    "col_2": "What is a pair?",
    "col_3": "Container consisting of two data elements of the same type",
    "col_4": "Container consisting of two data elements of different type",
    "col_5": "Container consisting of one header and two data elements of the same type",
    "col_6": "Container consisting of two data elements can have the same or different type",
    "col_7": "Container consisting of two data elements can have the same or different type",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 717,
    "col_2": "Which header file is required to use pair container in your program?",
    "col_3": "<algorihtm>",
    "col_4": "<utility>",
    "col_5": "<pair>",
    "col_6": "<utitityPair>",
    "col_7": "<utility>",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 718,
    "col_2": "Which of the following is the correct syntax of using pair p?",
    "col_3": "pair <type,type> p;",
    "col_4": "pair p <type,type>;",
    "col_5": "pair [type,type] p;",
    "col_6": "pair p [type,type];",
    "col_7": "pair <type,type> p;",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 719,
    "col_2": "Which of the following operations can be performed on a pair?",
    "col_3": "Assignment of pairs",
    "col_4": "Copying of one pair to another",
    "col_5": "Comparison of two pairs",
    "col_6": "All of the mentioned",
    "col_7": "All of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 720,
    "col_2": "Which operator is used to access the first or second element of a pair?",
    "col_3": "->",
    "col_4": ".",
    "col_5": "*",
    "col_6": [],
    "col_7": ".",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 721,
    "col_2": "Which of the following is the correct syntax of accessing the first element of a pair p?",
    "col_3": "p.first",
    "col_4": "p.second",
    "col_5": "p[0]",
    "col_6": "p[1]",
    "col_7": "p.first",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 722,
    "col_2": "Which of the following is the correct syntax of accessing the second element of a pair p?",
    "col_3": "p.first",
    "col_4": "p.second",
    "col_5": "p[0]",
    "col_6": "p[1]",
    "col_7": "p.second",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 723,
    "col_2": "What happens if a pair is not initialized?",
    "col_3": "Both first and second part is initialized to zero or null",
    "col_4": "Both first and second part is initialized a garbage value",
    "col_5": "First is initialized to zero or null and second is initialized a garbage value",
    "col_6": "Second is initialized to zero or null and first is initialized a garbage value",
    "col_7": "Both first and second part is initialized to zero or null",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 724,
    "col_2": "Which of the following Operator cannot be used with pairs?",
    "col_3": "+",
    "col_4": "==",
    "col_5": "=",
    "col_6": "!=",
    "col_7": "+",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 725,
    "col_2": "What is any in C++?",
    "col_3": "STL container used to store a single value of any type",
    "col_4": "Exception class in C++",
    "col_5": "Fundamental type provided by C++",
    "col_6": "Template data type",
    "col_7": "STL container used to store a single value of any type",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 726,
    "col_2": "In how many different ways any-container can be constructed?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 3,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 727,
    "col_2": "Which of the following syntax is used to convert any variable to its original type?",
    "col_3": "any_cast<variable_name>();",
    "col_4": "any_cast(variable_name);",
    "col_5": "<original_type>(variable_name);",
    "col_6": "any_cast<original_type>(variable_name);",
    "col_7": "any_cast<original_type>(variable_name);",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 728,
    "col_2": "Which header file is required to use any container?",
    "col_3": "<any>",
    "col_4": "<stl>",
    "col_5": "<container-any>",
    "col_6": "<containers>",
    "col_7": "<any>",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 729,
    "col_2": "Which exception is thrown if the typecasting is not done properly?",
    "col_3": "bad_type_cast",
    "col_4": "bad_any_cast",
    "col_5": "type_mismatched",
    "col_6": "bad_cast_mismatched",
    "col_7": "bad_any_cast",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 730,
    "col_2": "What is the use of emplace() function?",
    "col_3": "Used to change the object any container is holding",
    "col_4": "Used to add more item to the any list",
    "col_5": "Used to empty any container value",
    "col_6": "Used to check the type of any variable",
    "col_7": "Used to change the object any container is holding",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 731,
    "col_2": "What is the use of type() function in any container?",
    "col_3": "Used to destroys the contained object in any variable",
    "col_4": "Used to change the object any container is holding",
    "col_5": "Used to return the type information about the any container",
    "col_6": "Used to check whether a container is empty or not",
    "col_7": "Used to return the type information about the any container",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 732,
    "col_2": "What is the use of has_value() function in any container?",
    "col_3": "Used to destroys the contained object in any variable",
    "col_4": "Used to change the object any container is holding",
    "col_5": "Used to return the type information about the any container",
    "col_6": "Used to check whether any container is empty or not",
    "col_7": "Used to check whether any container is empty or not",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 733,
    "col_2": "What is the use of reset() function?",
    "col_3": "Used to destroys the contained object in any variable",
    "col_4": "Used to change the object any container is holding",
    "col_5": "Used to empty any container value",
    "col_6": "Used to check the type of any variable",
    "col_7": "Used to destroys the contained object in any variable",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 734,
    "col_2": "In how many ways we can handle errors in any class?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 2,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 735,
    "col_2": "Which type of heap is implemented in STL heap?",
    "col_3": "max heap",
    "col_4": "min heap",
    "col_5": "middle heap",
    "col_6": "close heap",
    "col_7": "max heap",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 736,
    "col_2": "Which function is used to construct heap from given sequence of numbers?",
    "col_3": "create_heap()",
    "col_4": "make_heap()",
    "col_5": "construct_heap()",
    "col_6": "start_heap()",
    "col_7": "make_heap()",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 737,
    "col_2": "What is the use of front() function in heap?",
    "col_3": "Returns the element closest to the median of a sequence",
    "col_4": "Returns the last element of the heap",
    "col_5": "Returns the first element of the heap",
    "col_6": "Returns the element closest to mean of a sequence",
    "col_7": "Returns the first element of the heap",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 738,
    "col_2": "Which function is used to insert an element into heap?",
    "col_3": "push_back()",
    "col_4": "push_heap()",
    "col_5": "pop_back()",
    "col_6": "pop_heap()",
    "col_7": "push_heap()",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 739,
    "col_2": "Elements in STL heap are removed in ________________________",
    "col_3": "decreasing order",
    "col_4": "increasing order",
    "col_5": "alternate i.e. once max element then min element",
    "col_6": "input order",
    "col_7": "decreasing order",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 740,
    "col_2": "Which header file is required to use heap in your program?",
    "col_3": "<heap>",
    "col_4": "<algorithm>",
    "col_5": "<vector>",
    "col_6": "<map>",
    "col_7": "<algorithm>",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 741,
    "col_2": "Which of the following is correct syntax of making heap from a vector v?",
    "col_3": "make_heap(v.elements);",
    "col_4": "make_heap(v);",
    "col_5": "make_heap(v.end(), v.begin());",
    "col_6": "make_heap(v.begin(), v.end());",
    "col_7": "make_heap(v.begin(), v.end());",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 742,
    "col_2": "What is the use of sort_heap() function in heap?",
    "col_3": "To sort the elements in the heap into descending order",
    "col_4": "To sort the elements in the heap into ascending order",
    "col_5": "To sort the first half of the heap",
    "col_6": "To sort the second half of the heap",
    "col_7": "To sort the elements in the heap into ascending order",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 743,
    "col_2": "Which function is used to check whether a given sequence is heap or not?",
    "col_3": "sort_heap()",
    "col_4": "is_heap()",
    "col_5": "is_heap_until()",
    "col_6": "check_heap()",
    "col_7": "is_heap()",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 744,
    "col_2": "What is the use of is_heap_until() function?",
    "col_3": "Returns the iterator of the last element of the sequence always",
    "col_4": "Returns the iterator to the position from where the sequence is a heap",
    "col_5": "Returns the iterator of the position till that the sequence is a heap",
    "col_6": "Returns the iterator of the first element of the sequence",
    "col_7": "Returns the iterator of the position till that the sequence is a heap",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 745,
    "col_2": "What is vtable in C++?",
    "col_3": "Lookup table to resolve function calls in dynamic manners",
    "col_4": "Lookup table to resolve function calls in static manners",
    "col_5": "Lookup table to see which are the functions available for calls throughout the program",
    "col_6": "Lookup table to check how many functions are there int he program",
    "col_7": "Lookup table to resolve function calls in dynamic manners",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 746,
    "col_2": "Which classes can have vtable?",
    "col_3": "Classes having friend functions",
    "col_4": "Classes having virtual functions",
    "col_5": "Classes having static functions",
    "col_6": "All classes have a vtable",
    "col_7": "Classes having virtual functions",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 747,
    "col_2": "What is the full form of vtable?",
    "col_3": "V type table",
    "col_4": "Vector table",
    "col_5": "Virtual table",
    "col_6": "Virtual-vector table",
    "col_7": "Virtual table",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 748,
    "col_2": "What is vptr?",
    "col_3": "A hidden pointer in a class that points to a virtual table of that class",
    "col_4": "A hidden pointer in a class that points to virtual functions of that class",
    "col_5": "A hidden pointer in a class that points to virtual members of the class of that class",
    "col_6": "A pointer in a class that points to other class",
    "col_7": "A hidden pointer in a class that points to a virtual table of that class",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 749,
    "col_2": "What is the full form of vptr?",
    "col_3": "Vector Pointer",
    "col_4": "Virtual Pointer",
    "col_5": "V type Pointer",
    "col_6": "Virtual-vector Pointer",
    "col_7": "Vector Pointer",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 750,
    "col_2": "vptr is _______________",
    "col_3": "a real pointer",
    "col_4": "like this pointer of class",
    "col_5": "passed as a parameter to all functions of class",
    "col_6": "used to resolve self-references",
    "col_7": "a real pointer",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 751,
    "col_2": "What are the Generators in C++?",
    "col_3": "An object that generates uniformly distributed numbers",
    "col_4": "An object that generates a number from a given sequence",
    "col_5": "An object that generates the smallest number from a given range",
    "col_6": "An object that generates unique numbers",
    "col_7": "An object that generates uniformly distributed numbers",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 752,
    "col_2": "What are Distributions in C++?",
    "col_3": "Objects that converts a sequence into a sequence having an ascending order",
    "col_4": "Objects that converts a sequence into a sequence having specific random variable distribution",
    "col_5": "Objects that converts a sequence into a sequence having a descending order",
    "col_6": "Objects that converts a sequence into a sequence having only the smallest, largest and median",
    "col_7": "Objects that converts a sequence into a sequence having specific random variable distribution",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 753,
    "col_2": "Which header file is used for generating random numbers?",
    "col_3": "<gen_dist>",
    "col_4": "<distribution>",
    "col_5": "<generator>",
    "col_6": "<random>",
    "col_7": "<random>",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 754,
    "col_2": "What is Pseudo-random number engines?",
    "col_3": "Uses user input for random number generation",
    "col_4": "Uses an algorithm that does not require any initial seed to generate random numbers",
    "col_5": "Uses initial seed based algorithm to generate random numbers",
    "col_6": "Random number generates depends on the program",
    "col_7": "Uses initial seed based algorithm to generate random numbers",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 755,
    "col_2": "How many Pseudo-random number engines are there?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 3,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 756,
    "col_2": "What are different operations are used in Pseudo-random number engines?",
    "col_3": "operator()",
    "col_4": "min()",
    "col_5": "max()",
    "col_6": "all of the mentioned",
    "col_7": "all of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 757,
    "col_2": "What is a Random number generator?",
    "col_3": "A generator that generates deterministic random numbers",
    "col_4": "A generator that generates both non-deterministic random numbers and deterministic random numbers",
    "col_5": "A generator that generates non-deterministic random numbers",
    "col_6": "A generator that generates a simple random number",
    "col_7": "A generator that generates non-deterministic random numbers",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 758,
    "col_2": "What is random_device?",
    "col_3": "A pseudo-random number generator",
    "col_4": "Time-dependent random number generator",
    "col_5": "Simple random number generator",
    "col_6": "A true random number generator",
    "col_7": "A true random number generator",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 759,
    "col_2": "Which algorithm is used in subtract_with_carry_engine?",
    "col_3": "Mersenne Twister algorithm",
    "col_4": "Lagged fibonacci generator algorithm",
    "col_5": "Either the Mersenne Twister algorithm or Lagged fibonacci generator algorithm",
    "col_6": "Fibonacci generator",
    "col_7": "Lagged fibonacci generator algorithm",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 760,
    "col_2": "What is the default random engine?",
    "col_3": "Random number engine that generates pseudo-random numbers",
    "col_4": "Mersenne Twister 19937 generator generating 32-bit true random number",
    "col_5": "Random number engine that generates true random numbers",
    "col_6": "Mersenne Twister 19937 generator generating 32-bit pseudo random number",
    "col_7": "Random number engine that generates pseudo-random numbers",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 761,
    "col_2": "What are Engine Adaptors?",
    "col_3": "Class template that adopts a pseudo-random number generator engine",
    "col_4": "Class template that adopts a pseudo-random number generator engine to produce numbers with a given numbers of bits",
    "col_5": "Random number engine that generates pseudo-random numbers",
    "col_6": "Mersenne Twister 19937 generator generating 32-bit true random number",
    "col_7": "Class template that adopts a pseudo-random number generator engine to produce numbers with a given numbers of bits",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 762,
    "col_2": "How many Engine Adaptors are there in C++?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 3,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 763,
    "col_2": "Which of the header file is used for array type manipulation?",
    "col_3": "<array>",
    "col_4": "<type_traits>",
    "col_5": "<iostream>",
    "col_6": "std namespace",
    "col_7": "std namespace",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 764,
    "col_2": "What is the use of is_array() function in C++?",
    "col_3": "To check if a variable is array type or not",
    "col_4": "To check if a variable is 1-D array type or not",
    "col_5": "To check if a variable is 2-D array type or not",
    "col_6": "To check if a variable is 1-D or 2-D array type or not",
    "col_7": "To check if a variable is array type or not",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 765,
    "col_2": "What is the use of is_same() function in C++?",
    "col_3": "To check if a variable is array type or not",
    "col_4": "To check whether two variables have the same characteristics",
    "col_5": "To check if two variable is of array type or not",
    "col_6": "To check whether two variables are different or not",
    "col_7": "To check whether two variables have the same characteristics",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 766,
    "col_2": "What is the use of rank() function in C++?",
    "col_3": "Returns size of each dimension",
    "col_4": "Returns how many total elements can be stored in an array",
    "col_5": "Returns how many elements are in array currently",
    "col_6": "Returns the dimension of an array",
    "col_7": "Returns the dimension of an array",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 767,
    "col_2": "Which of the following is correct about extent() function?",
    "col_3": "Returns how many elements are in array currently",
    "col_4": "Returns the size of the 1st dimension",
    "col_5": "Returns how many total elements can be stored in an array",
    "col_6": "Returns the size of a given dimension",
    "col_7": "Returns the size of a given dimension",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 768,
    "col_2": "Which of the following is correct about remove_extent() function?",
    "col_3": "Removes the given dimension from an array",
    "col_4": "Removes the first dimension from the right of the array",
    "col_5": "Removes the first dimension from the left of the array",
    "col_6": "Removes the last dimension from the left of the array",
    "col_7": "Removes the first dimension from the left of the array",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 769,
    "col_2": "Which of the following is correct about remove_all_extents() function?",
    "col_3": "Removes the all dimension from an array",
    "col_4": "Removes the first dimension from the left of the array",
    "col_5": "Removes the first dimension from the right of the array",
    "col_6": "Removes the last dimension from the left of the array",
    "col_7": "Removes the all dimension from an array",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 770,
    "col_2": "What are the tuples in C++?",
    "col_3": "Objects that can hold more than one element of different types",
    "col_4": "Objects that can hold a single element of complex type",
    "col_5": "Objects that can hold more than one element of the same types",
    "col_6": "Objects that can hold a single element of fundamental type",
    "col_7": "Objects that can hold more than one element of different types",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 771,
    "col_2": "Which of the following is correct about tuples?",
    "col_3": "A tuple can hold more than one element",
    "col_4": "A tuple can hold elements having different types",
    "col_5": "Elements of tuples are initialized in order",
    "col_6": "All of the mentioned",
    "col_7": "All of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 772,
    "col_2": "Which header file is required to use tuples in your program?",
    "col_3": "<stl>",
    "col_4": "<array>",
    "col_5": "<slgorithm>",
    "col_6": "<tuple>",
    "col_7": "<tuple>",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 773,
    "col_2": "Which of the following is the correct way of declaring a tuple?",
    "col_3": "tuple tp<type1, type2, type3>;",
    "col_4": "tuple tp = new tuple<type1, type2, type3>;",
    "col_5": "tuple <type1, type2, type3> tp;",
    "col_6": "Tuple <type1, type2, type3> tp;",
    "col_7": "tuple <type1, type2, type3> tp;",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 774,
    "col_2": "Which of the following function is used to initialize a tuple?",
    "col_3": "make()",
    "col_4": "make_pair()",
    "col_5": "make_tuple()",
    "col_6": "make_Tuple()",
    "col_7": "make_tuple()",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 775,
    "col_2": "Which of the following is correct about tuple_size?",
    "col_3": "Returns the number of elements in a tuple",
    "col_4": "Returns the maximum sized type element",
    "col_5": "Returns the total number of bits used by the tuple",
    "col_6": "Returns the sum of non-string values",
    "col_7": "Returns the number of elements in a tuple",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 776,
    "col_2": "Which of the following is correct about swap()?",
    "col_3": "Swaps first element of both tuples",
    "col_4": "Swaps two tuples",
    "col_5": "Swaps elements of a tuple alternatively",
    "col_6": "Swaps last elements of two tuples",
    "col_7": "Swaps two tuples",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 777,
    "col_2": "What is the use of tie() function?",
    "col_3": "Used to replace elements",
    "col_4": "Used to delete elements",
    "col_5": "Used to unpack the values of a tuple",
    "col_6": "Used to check whether two tuples are the same or not",
    "col_7": "Used to unpack the values of a tuple",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 778,
    "col_2": "How many variants of tie() function is there?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 2,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 779,
    "col_2": "Which word is used to stop the unpacking of a value in a tuple?",
    "col_3": "stop",
    "col_4": "ignore",
    "col_5": "cancel",
    "col_6": "remain",
    "col_7": "ignore",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 780,
    "col_2": "What is the use of tuple_cat() function?",
    "col_3": "Takes the union of two tuples",
    "col_4": "Takes the intersection of two tuples",
    "col_5": "Concatenates two tuples",
    "col_6": "Removes elements of the second tuple from first",
    "col_7": "Concatenates two tuples",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 781,
    "col_2": "Which header file is required to use complex class in your program?",
    "col_3": "<complex>",
    "col_4": "<math>",
    "col_5": "<complex_math>",
    "col_6": "<algorithm>",
    "col_7": "<complex>",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 782,
    "col_2": "Which of the following is the correct syntax of declaring a complex number?",
    "col_3": "complex variable_name<type>;",
    "col_4": "complex<type> variable_name;",
    "col_5": "Complex<type> variable_name;",
    "col_6": "Complex variable_name<type>;",
    "col_7": "complex<type> variable_name;",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 783,
    "col_2": "Which function is used to get the real part of the complex number?",
    "col_3": "img_p()",
    "col_4": "imag_p()",
    "col_5": "real()",
    "col_6": "real_p()",
    "col_7": "real()",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 784,
    "col_2": "Which function is used to get the imaginary part of the complex number?",
    "col_3": "real()",
    "col_4": "imag()",
    "col_5": "imag_p()",
    "col_6": "real_p()",
    "col_7": "imag()",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 785,
    "col_2": "Which function is used to get the argument of a complex number?",
    "col_3": "abs()",
    "col_4": "norm()",
    "col_5": "arg()",
    "col_6": "argu()",
    "col_7": "arg()",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 786,
    "col_2": "What is the use of polar function?",
    "col_3": "Used to construct a complex number from the real and imaginary part",
    "col_4": "Used to construct a complex number from magnitude and phase angle",
    "col_5": "Used to construct a complex number from the magnitude and real part",
    "col_6": "Used to construct a complex number from argument and phase angle",
    "col_7": "Used to construct a complex number from magnitude and phase angle",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 787,
    "col_2": "Which function is used to calculate the norm of a complex number?",
    "col_3": "abs()",
    "col_4": "norm()",
    "col_5": "mod()",
    "col_6": "square_sum()",
    "col_7": "norm()",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 788,
    "col_2": "Which function is used to calculate the conjugate of a complex number?",
    "col_3": "conj()",
    "col_4": "reverse()",
    "col_5": "opp()",
    "col_6": "find_conj()",
    "col_7": "conj()",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 789,
    "col_2": "What is the use of proj() function?",
    "col_3": "Used to calculate the argument of a complex number",
    "col_4": "Used to calculate the conjugate of a complex number",
    "col_5": "Used to calculate the negative of a complex number",
    "col_6": "Used to calculate the projection of a complex number",
    "col_7": "Used to calculate the projection of a complex number",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 790,
    "col_2": "What is the use of log() function in a complex?",
    "col_3": "To calculate the log of the imaginary part of a complex number",
    "col_4": "To calculate the log of rethe al part of a complex number",
    "col_5": "To calculate the log of a complex number",
    "col_6": "To calculate the log of the argument of a complex number",
    "col_7": "To calculate the log of a complex number",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 791,
    "col_2": "What is Valarray in C++?",
    "col_3": "Container for efficient operations on an array",
    "col_4": "Container for efficient printing of the array",
    "col_5": "Container for efficient value conversion of array",
    "col_6": "Container for efficient type conversion of array",
    "col_7": "Container for efficient operations on an array",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 792,
    "col_2": "Which of the following is correct about Valarray?",
    "col_3": "Supports element-wise mathematical operations",
    "col_4": "Slower than a normal array",
    "col_5": "Harder to use",
    "col_6": "Can have only integer Valarrays",
    "col_7": "Supports element-wise mathematical operations",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 793,
    "col_2": "Which header file is required for using Valarray?",
    "col_3": "<array>",
    "col_4": "<Valarray>",
    "col_5": "<stl>",
    "col_6": "<algorithm>",
    "col_7": "<Valarray>",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 794,
    "col_2": "What is the use of apply() function in Valarray?",
    "col_3": "Returns new array after shifting elements by the given number",
    "col_4": "Returns the summation of all elements of the Valarray",
    "col_5": "Applies the manipulation provided to all the elements of the array",
    "col_6": "Returns new array after circular shifting elements by the given number",
    "col_7": "Applies the manipulation provided to all the elements of the array",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 795,
    "col_2": "What is the use of sum() function in Valarray?",
    "col_3": "Applies the manipulation provided to all the elements of the array",
    "col_4": "Returns the summation of all elements of Valarray",
    "col_5": "Returns new array after shifting elements by the given number",
    "col_6": "Returns new array after circular shifting elements by the given number",
    "col_7": "Returns the summation of all elements of Valarray",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 796,
    "col_2": "What is the function of shift()?",
    "col_3": "Applies the manipulation provided to all the elements of the array",
    "col_4": "Returns the summation of all elements of Valarray",
    "col_5": "Returns new array after shifting elements by the given number",
    "col_6": "Returns new array after circular shifting elements by the given number",
    "col_7": "Returns new array after shifting elements by the given number",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 797,
    "col_2": "Which of the following is correct about the shift?",
    "col_3": "Returns new array after shifting elements by the given number",
    "col_4": "Shifts the elements towards left if the argument supplied is positive",
    "col_5": "Shifts the elements towards the right if the argument supplied is negative",
    "col_6": "All of the mentioned",
    "col_7": "All of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 798,
    "col_2": "Which function is used to swap two Valarray?",
    "col_3": "max()",
    "col_4": "min()",
    "col_5": "swap()",
    "col_6": "change()",
    "col_7": "swap()",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 799,
    "col_2": "Which function is used to print the maximum element from Valarray?",
    "col_3": "change()",
    "col_4": "min()",
    "col_5": "swap()",
    "col_6": "max()",
    "col_7": "max()",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 800,
    "col_2": "What is bitset in C++?",
    "col_3": "An array of bools consuming one bit per element",
    "col_4": "Vector of bools",
    "col_5": "C-like arrays of bool elements",
    "col_6": "Template class",
    "col_7": "An array of bools consuming one bit per element",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 801,
    "col_2": "Which of the following is correct about bitset and vector of bools?",
    "col_3": "Space consumed by bitset is less than vector<bool>",
    "col_4": "Bitset consume only 1 bit per element",
    "col_5": "Number of elements in bitset should be known at compile time whereas vector can have a dynamic size",
    "col_6": "All of the mentioned",
    "col_7": "All of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 802,
    "col_2": "Which of the following is the limitation of bitset over vector bool?",
    "col_3": "Space",
    "col_4": "Size",
    "col_5": "Type",
    "col_6": "Speed",
    "col_7": "Size",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 803,
    "col_2": "Which operator is used to access the nth bit in a bitset?",
    "col_3": "->",
    "col_4": [],
    "col_5": ".",
    "col_6": "*",
    "col_7": [],
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 804,
    "col_2": "How many ways are there for constructing a bitset?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 3,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 805,
    "col_2": "Which is the correct syntax of constructing a bitset?",
    "col_3": "bitset<size> b;",
    "col_4": "bitset<size> b(12);",
    "col_5": "bitset<size> b(string(\"1100\"));",
    "col_6": "all of the mentioned",
    "col_7": "all of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 806,
    "col_2": "Which of the following is corect way of constructing bitset using integer number?",
    "col_3": "bitset<size> b;",
    "col_4": "bitset<size> b(12);",
    "col_5": "bitset<size> b(string(\"1100\"));",
    "col_6": "bitset<size> b(float(12));",
    "col_7": "bitset<size> b(12);",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 807,
    "col_2": "Which of the following is corect way of constructing bitset using binary string?",
    "col_3": "bitset<size> b;",
    "col_4": "bitset<size> b(12);",
    "col_5": "bitset<size> b(string(\"1100\"));",
    "col_6": "bitset<size> b(float(12));",
    "col_7": "bitset<size> b(string(\"1100\"));",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 808,
    "col_2": "What is the default value of a bitset?",
    "col_3": "All bits are 0",
    "col_4": "All bits are 1",
    "col_5": "Leftmost bit is 0",
    "col_6": "Rightmost bit is 0",
    "col_7": "All bits are 0",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 809,
    "col_2": "Which header file is required for using bitset in your program?",
    "col_3": "<bit>",
    "col_4": "<bitset>",
    "col_5": "<bits>",
    "col_6": "<BitSet>",
    "col_7": "<bitset>",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 810,
    "col_2": "Indexing of bitset variables starts from ___________",
    "col_3": "leftmost bit",
    "col_4": "rightmost bit",
    "col_5": "same as in an array",
    "col_6": "front",
    "col_7": "rightmost bit",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 811,
    "col_2": "What is the use of count() function in bitset?",
    "col_3": "To count the number of 0's",
    "col_4": "To count the number of 1's",
    "col_5": "To count the number of total bits in a bitset",
    "col_6": "To count the number of low bits",
    "col_7": "To count the number of 1's",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 812,
    "col_2": "What does size() function returns?",
    "col_3": "To count the number of 0's",
    "col_4": "To count the number of 1's",
    "col_5": "To count the number of total bits used by bitset variable",
    "col_6": "To count the number of low bits",
    "col_7": "To count the number of total bits used by bitset variable",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 813,
    "col_2": "Which of the following is correct about any() function in bitset?",
    "col_3": "Returns true if the number of 1's equal to the number of 0's",
    "col_4": "Returns true if any bit is set 0",
    "col_5": "Returns true if any bit is set 1",
    "col_6": "Returns true only if all bits are 1",
    "col_7": "Returns true if any bit is set 1",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 814,
    "col_2": "Which of the following is correct about none() function in bitset?",
    "col_3": "Returns true if any bits is set 1",
    "col_4": "Returns true if all bits is set 0",
    "col_5": "Returns true if the number of 1's equal to the number of 0's",
    "col_6": "Returns true only if all bits are 1",
    "col_7": "Returns true if all bits is set 0",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 815,
    "col_2": "What is the use of the set() function in bitset?",
    "col_3": "Used to make alternate bits zero",
    "col_4": "Used to make a bit 0 in a bitset",
    "col_5": "Used to make all bits zero",
    "col_6": "Used to set bit(s) in a bitset",
    "col_7": "Used to set bit(s) in a bitset",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 816,
    "col_2": "What happens when no argument is supplied to set() function?",
    "col_3": "All alternate bits are set to 1 in a bitset",
    "col_4": "All bits are set to 0 in a bitset",
    "col_5": "All bits are set to 1 in a bitset",
    "col_6": "First bit is set to 1",
    "col_7": "All bits are set to 1 in a bitset",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 817,
    "col_2": "What happens when only one argument is supplied to set() function?",
    "col_3": "All bits are set to 1 in a bitset",
    "col_4": "Bit corresponding to an argument is set to 1",
    "col_5": "All alternate bits are set to 1 in a bitset",
    "col_6": "First bit is set to 1",
    "col_7": "Bit corresponding to an argument is set to 1",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 818,
    "col_2": "What is the use of reset function in bitset?",
    "col_3": "Used to make alternate bits zero",
    "col_4": "Used to make a bit 0 in a bitset",
    "col_5": "Used to make all bits 1",
    "col_6": "Used to make a bit(s) 0 in a bitset",
    "col_7": "Used to make a bit(s) 0 in a bitset",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 819,
    "col_2": "What happens when no argument is supplied to reset() function?",
    "col_3": "All bits are set to 1 in a bitset",
    "col_4": "All bits are set to 0 in a bitset",
    "col_5": "All alternate bits are set to 0 in a bitset",
    "col_6": "First bit is set to 0",
    "col_7": "All bits are set to 0 in a bitset",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 820,
    "col_2": "What happens when only one argument is supplied to reset() function?",
    "col_3": "Bit corresponding to an argument is set to 0",
    "col_4": "All bits are set to 0 in a bitset",
    "col_5": "All alternate bits are set to 0 in a bitset",
    "col_6": "First bit is set to 0",
    "col_7": "Bit corresponding to an argument is set to 0",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 821,
    "col_2": "What is the use of the flip function in bitset?",
    "col_3": "Used to flip bit(s) in a bitset",
    "col_4": "Used to flip a bit in a bitset",
    "col_5": "Used to flip all bits to 1",
    "col_6": "Used to flip alternate bits",
    "col_7": "Used to flip bit(s) in a bitset",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 822,
    "col_2": "What happens when no argument is supplied to flip() function?",
    "col_3": "All alternate bits are flipped in a bitset",
    "col_4": "All bits are flipped to 1 in a bitset",
    "col_5": "All bits are flipped in a bitset",
    "col_6": "First bit is flipped",
    "col_7": "All bits are flipped in a bitset",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 823,
    "col_2": "What happens when only one argument is supplied to flip() function?",
    "col_3": "All bits are flipped in a bitset",
    "col_4": "Bit corresponding to argument bit is flipped",
    "col_5": "All alternate bits are flipped in a bitset",
    "col_6": "First bit is flipped",
    "col_7": "Bit corresponding to argument bit is flipped",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 824,
    "col_2": "What is the class relationship?",
    "col_3": "A relationship between classes that tells how they are related",
    "col_4": "A relationship between classes that tells how much power one class has over other class",
    "col_5": "A relationship between classes that tells which parts of a class is visible to other classes",
    "col_6": "All of the mentioned",
    "col_7": "All of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 825,
    "col_2": "How many types of class relationships are there?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 4,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 826,
    "col_2": "Which type of relationship is modelled by Inheritance?",
    "col_3": "Is-A relationship",
    "col_4": "Has-A relationship",
    "col_5": "Part-Of relationship",
    "col_6": "Belongs-to relationship",
    "col_7": "Is-A relationship",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 827,
    "col_2": "How the relationship is made in Association?",
    "col_3": "Through the objects of classes",
    "col_4": "Through constructor",
    "col_5": "Through destructor",
    "col_6": "Through class Names",
    "col_7": "Through the objects of classes",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 828,
    "col_2": "How many types of Association can be there between classes?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 4,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 829,
    "col_2": "Why do we need relationships between classes?",
    "col_3": "To use the functionality of one class into other",
    "col_4": "To enhance the communication between classes",
    "col_5": "To increase code re-usability",
    "col_6": "All of the mentioned",
    "col_7": "All of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 830,
    "col_2": "Composition is also a type of _______________ relationship.",
    "col_3": "Aggregation",
    "col_4": "Association",
    "col_5": "Inheritance",
    "col_6": "Both Aggregation an Association",
    "col_7": "Association",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 831,
    "col_2": "Which type of relationship is modelled by Composition?",
    "col_3": "Is-A relationship",
    "col_4": "Has-A relationship",
    "col_5": "Part-Of relationship",
    "col_6": "Have-A relationship",
    "col_7": "Part-Of relationship",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 832,
    "col_2": "Which type of relationship is modelled by Aggregation?",
    "col_3": "Is-A relationship",
    "col_4": "Has-A relationship",
    "col_5": "Part-Of relationship",
    "col_6": "Have-A relationship",
    "col_7": "Has-A relationship",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 833,
    "col_2": "Which of the following relationships is uni-directional?",
    "col_3": "Aggregation",
    "col_4": "Association",
    "col_5": "Composition",
    "col_6": "Both Aggregation and Composition",
    "col_7": "Both Aggregation and Composition",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 834,
    "col_2": "In which of the following relationship objects of related classes can occur independently?",
    "col_3": "Aggregation",
    "col_4": "Association",
    "col_5": "Composition",
    "col_6": "Both Aggregation an Association",
    "col_7": "Both Aggregation an Association",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 835,
    "col_2": "In which of the following relationship objects of related classes are strongly dependent?",
    "col_3": "Aggregation",
    "col_4": "Association",
    "col_5": "Composition",
    "col_6": "Both Composition an Association",
    "col_7": "Both Composition an Association",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 836,
    "col_2": "Composition is a __________ type of Association relationship.",
    "col_3": "strong",
    "col_4": "weak",
    "col_5": "unnecessary",
    "col_6": "necessary",
    "col_7": "strong",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 837,
    "col_2": "Aggregation is a __________ type of Association relationship.",
    "col_3": "strong",
    "col_4": "weak",
    "col_5": "unnecessary",
    "col_6": "necessary",
    "col_7": "weak",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 838,
    "col_2": "Which type of relationship is modelled by Association?",
    "col_3": "Is-A relationship",
    "col_4": "Has-A relationship",
    "col_5": "Part-Of relationship",
    "col_6": "Have-A relationship",
    "col_7": "Has-A relationship",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 839,
    "col_2": "Which container is used to store elements as key-value pair?",
    "col_3": "map",
    "col_4": "multimap",
    "col_5": "unordered map",
    "col_6": "all of the mentioned",
    "col_7": "all of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 840,
    "col_2": "Which container can have the same keys?",
    "col_3": "map",
    "col_4": "multimap",
    "col_5": "unordered map",
    "col_6": "set",
    "col_7": "multimap",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 841,
    "col_2": "Which container is best to keep the collection of distinct elements?",
    "col_3": "multimap",
    "col_4": "heap",
    "col_5": "set",
    "col_6": "queue",
    "col_7": "set",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 842,
    "col_2": "Which container is used to keep priority based elements?",
    "col_3": "queue",
    "col_4": "stack",
    "col_5": "set",
    "col_6": "priority queue",
    "col_7": "priority queue",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 843,
    "col_2": "Sets are implemented using _______________________",
    "col_3": "binary search tree",
    "col_4": "red black tree",
    "col_5": "avl tree",
    "col_6": "heap",
    "col_7": "binary search tree",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 844,
    "col_2": "Unordered map is implemented using _________________",
    "col_3": "binary search tree",
    "col_4": "red black tree",
    "col_5": "heap",
    "col_6": "hash table",
    "col_7": "hash table",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 845,
    "col_2": "Map is implemented using ____________________",
    "col_3": "binary search tree",
    "col_4": "red black tree",
    "col_5": "heap",
    "col_6": "hash table",
    "col_7": "red black tree",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 846,
    "col_2": "Which of the following is correct about the map and unordered map?",
    "col_3": "Ordering of keys in maps whereas no such order in the unordered map",
    "col_4": "Maps are implemented red-black trees whereas unordered map are implemented using hash tables",
    "col_5": "Average search time in the unordered map is O(1) whereas it is O(logn) in case of maps",
    "col_6": "All of the mentioned",
    "col_7": "All of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 847,
    "col_2": "Which of the following queue container can expand or shrink from both directions?",
    "col_3": "deque",
    "col_4": "queue",
    "col_5": "priority queue",
    "col_6": "stack",
    "col_7": "deque",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 848,
    "col_2": "Which of the following is correct about map and multimap?",
    "col_3": "Map can have same keys whereas multimap cannot",
    "col_4": "Implementation of maps and multimap are different",
    "col_5": "Multimap can have same keys whereas the map cannot",
    "col_6": "Average search time of map is greater than multimap",
    "col_7": "Multimap can have same keys whereas the map cannot",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 849,
    "col_2": "What is the header file used for declaring the standard library algorithms?",
    "col_3": "container",
    "col_4": "algorithm",
    "col_5": "library",
    "col_6": "iterator",
    "col_7": "algorithm",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 850,
    "col_2": "Pick out the correct method in the c++ standard library algorithm.",
    "col_3": "mismatch",
    "col_4": "maximum",
    "col_5": "minimum",
    "col_6": "maxmatch",
    "col_7": "mismatch",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 851,
    "col_2": "What is the use of make_heap in the heap operation?",
    "col_3": "Rearrange a heap",
    "col_4": "Deform a heap",
    "col_5": "Form a heap",
    "col_6": "Delete a heap",
    "col_7": "Form a heap",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 852,
    "col_2": "What is the type of the first item in the heap?",
    "col_3": "Bigger than others",
    "col_4": "Lower than others",
    "col_5": "Mean value of the heap",
    "col_6": "Equal to others",
    "col_7": "Bigger than others",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 853,
    "col_2": "Pick out the correct library in the following choices.",
    "col_3": "Search",
    "col_4": "Generate",
    "col_5": "Numeric",
    "col_6": "All of the mentioned",
    "col_7": "All of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 854,
    "col_2": "What kind of iteration does forward_list provide in C++?",
    "col_3": "Uni-directional",
    "col_4": "Bi-directional",
    "col_5": "Multi-directional",
    "col_6": "Bi-directional & Multi-directional",
    "col_7": "Uni-directional",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 855,
    "col_2": "What does the size of the vector refers to in c++?",
    "col_3": "Size of vector",
    "col_4": "Type of vector",
    "col_5": "Number of elements",
    "col_6": "Name of vector",
    "col_7": "Number of elements",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 856,
    "col_2": "Subsequent elements are moved in terms of _____ when an element in inserted in vector?",
    "col_3": "Assignment Operator",
    "col_4": "Copy constructor",
    "col_5": "Both assignment operator and copy constructor",
    "col_6": "destructor",
    "col_7": "Both assignment operator and copy constructor",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 857,
    "col_2": "What is the use of adapter in STL in c++?",
    "col_3": "To provide interface",
    "col_4": "To manipulate the data",
    "col_5": "To extract the data",
    "col_6": "To delete the data",
    "col_7": "To provide interface",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 858,
    "col_2": "Which is used to iterate over container?",
    "col_3": "Associated iterator type",
    "col_4": "Data type of objects",
    "col_5": "Return type of variables",
    "col_6": "Name of the variables",
    "col_7": "Associated iterator type",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 859,
    "col_2": "What does the function objects implement?",
    "col_3": "operator",
    "col_4": "operator()",
    "col_5": "operand",
    "col_6": "operand<>",
    "col_7": "operator()",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 860,
    "col_2": "What are the two advantage of function objects than the function call?",
    "col_3": "It contains a state",
    "col_4": "It is a type",
    "col_5": "It contains a state & It is a type",
    "col_6": "It contains a prototype",
    "col_7": "It contains a state & It is a type",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 861,
    "col_2": "Which header is need to be used with function objects?",
    "col_3": "<function>",
    "col_4": "<functional>",
    "col_5": "<funct>",
    "col_6": "<functionstream>",
    "col_7": "<functional>",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 862,
    "col_2": "Which are instances of a class with member function operator() when it is defined?",
    "col_3": "function objects",
    "col_4": "member",
    "col_5": "methods",
    "col_6": "iterators",
    "col_7": "function objects",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 863,
    "col_2": "How many parameters does a operator() in a function object shoud take?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 2,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 864,
    "col_2": "How does a sequence of objects are accessed in c++?",
    "col_3": "Iterators",
    "col_4": "Pointers",
    "col_5": "Both Iterators & Pointers",
    "col_6": "Objects",
    "col_7": "Both Iterators & Pointers",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 865,
    "col_2": "How many parameters are present in mismatch method in non-sequence modifying algorithm?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": "3 or 4",
    "col_7": "3 or 4",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 866,
    "col_2": "What will happen in 'all_of' method if the range is empty?",
    "col_3": "Return true",
    "col_4": "Return false",
    "col_5": "Return nothing",
    "col_6": "Return error",
    "col_7": "Return true",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 867,
    "col_2": "To what kind of elements does non-modifying sequence algorithm can be applied?",
    "col_3": "Range",
    "col_4": "Vector",
    "col_5": "List",
    "col_6": "Methods",
    "col_7": "Range",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 868,
    "col_2": "Pick out the incorrect method in non-modifying sequence algorithm?",
    "col_3": "find-if",
    "col_4": "none-of",
    "col_5": "any-of",
    "col_6": "like",
    "col_7": "like",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 869,
    "col_2": "What is the use of middle parameter in the rotate method?",
    "col_3": "Marks the begining of a sequence",
    "col_4": "Marks the ending of a sequence",
    "col_5": "Marks the elements in a sequence",
    "col_6": "Marks the digits in a sequence",
    "col_7": "Marks the elements in a sequence",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 870,
    "col_2": "What kind of object is modifying sequence algorithm?",
    "col_3": "Function template",
    "col_4": "Class template",
    "col_5": "Method",
    "col_6": "Iterator",
    "col_7": "Function template",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 871,
    "col_2": "How the sequence of objects can be accessed?",
    "col_3": "Iterators",
    "col_4": "Pointers",
    "col_5": "Both Iterators & Pointers",
    "col_6": "Library",
    "col_7": "Both Iterators & Pointers",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 872,
    "col_2": "How many kind of operation can be applied to transform method in c++?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 2,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 873,
    "col_2": "What is meant by sequence point?",
    "col_3": "Represent the point of execution in the program",
    "col_4": "Represent the whole program",
    "col_5": "Represent the beginning of the program",
    "col_6": "Represent the end of the program",
    "col_7": "Represent the point of execution in the program",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 874,
    "col_2": "Pick out the correct statement about sequence point.",
    "col_3": "Sequence point will compile the program",
    "col_4": "Sequence point will resolve all the side effects",
    "col_5": "Sequence point will save the program for execution",
    "col_6": "Sequence point will delete the program for execution",
    "col_7": "Sequence point will resolve all the side effects",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 875,
    "col_2": "In sequence point, how will the overloaded operators behave like?",
    "col_3": "Function",
    "col_4": "Objects",
    "col_5": "Instance variable",
    "col_6": "Container",
    "col_7": "Function",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 876,
    "col_2": "What do input and output objects support?",
    "col_3": "Terminated sequences",
    "col_4": "Extracted sequences",
    "col_5": "Null-terminated sequences",
    "col_6": "Terminated & Extracted sequences",
    "col_7": "Null-terminated sequences",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 877,
    "col_2": "What kind of execution does sequence point allow?",
    "col_3": "Non-overlap",
    "col_4": "Overlap",
    "col_5": "Concurrent",
    "col_6": "Sequence",
    "col_7": "Non-overlap",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 878,
    "col_2": "When does the next sequence point start?",
    "col_3": "At the beginning",
    "col_4": "After a terminating semicolon",
    "col_5": "It is a beginning statement",
    "col_6": "At the end",
    "col_7": "After a terminating semicolon",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 879,
    "col_2": "What is meant by heap?",
    "col_3": "Used for fast retrieval of elements",
    "col_4": "Used for organising the elements",
    "col_5": "Used for fast retrieval & organising the elements",
    "col_6": "Used for deleting the elements",
    "col_7": "Used for fast retrieval & organising the elements",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 880,
    "col_2": "Which value is pointed out first in heap?",
    "col_3": "Lowest value",
    "col_4": "Highest value",
    "col_5": "First value",
    "col_6": "Third value",
    "col_7": "Highest value",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 881,
    "col_2": "Which operator is used to compare the elements in heap?",
    "col_3": ">>",
    "col_4": "comp",
    "col_5": "<",
    "col_6": "Both comp &<",
    "col_7": "Both comp &<",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 882,
    "col_2": "How to protect the heap from affecting the memory?",
    "col_3": "Avoid using pointers for associating two data structures",
    "col_4": "Embed pointed child objects into the parent object",
    "col_5": "Allocate objects in chunks",
    "col_6": "All of the mentioned",
    "col_7": "All of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 883,
    "col_2": "In what form does the STL provides heap?",
    "col_3": "queue",
    "col_4": "list",
    "col_5": "vector",
    "col_6": "priority_queue",
    "col_7": "priority_queue",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 884,
    "col_2": "How many types are there in binary heaps?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 2,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 885,
    "col_2": "Which keyword is used to declare the min and max functions?",
    "col_3": "iostream",
    "col_4": "string",
    "col_5": "algorithm",
    "col_6": "iterator",
    "col_7": "algorithm",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 886,
    "col_2": "What kind of functions are min and max in c++?",
    "col_3": "Type specific",
    "col_4": "Variable specific",
    "col_5": "Type & Variable specific",
    "col_6": "Iterator",
    "col_7": "Type specific",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 887,
    "col_2": "How many parameters are needed for minmax function?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": "All of the mentioned",
    "col_7": "All of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 888,
    "col_2": "Which function is used to return the minimum element in the range?",
    "col_3": "min",
    "col_4": "minimum",
    "col_5": "min_element",
    "col_6": "max_element",
    "col_7": "min_element",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 889,
    "col_2": "Which operator is used to compare the values to find min and max?",
    "col_3": "<",
    "col_4": ">",
    "col_5": "<<",
    "col_6": ">>",
    "col_7": "<",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 890,
    "col_2": "What is meant by permutation in c++?",
    "col_3": "To find all the values in the range",
    "col_4": "To find all the combination of the range",
    "col_5": "To find all the values & combination in the range",
    "col_6": "To delete all the values",
    "col_7": "To find all the combination of the range",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 891,
    "col_2": "How the different permutations are ordered in c++?",
    "col_3": "Compare lexicographically to each other elements",
    "col_4": "By finding the highest element in the range",
    "col_5": "By finding the lowest element in the range",
    "col_6": "By deleting the lowest element in the range",
    "col_7": "Compare lexicographically to each other elements",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 892,
    "col_2": "Pick out the correct statement about permutation.",
    "col_3": "If the function can determine the next higher permutation, Returns false",
    "col_4": "If the function can determine the next higher permutation, Returns true",
    "col_5": "If the function can't determine the next higher permutation, Returns true",
    "col_6": "If the function can determine the lower higher permutation, Returns true",
    "col_7": "If the function can determine the next higher permutation, Returns true",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 893,
    "col_2": "What is the header file for vector permutation?",
    "col_3": "vector_permutation.h",
    "col_4": "vector_perm",
    "col_5": "<algorithm>",
    "col_6": "vector_permutation",
    "col_7": "<algorithm>",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 894,
    "col_2": "How many parameters are required for next_permutation?",
    "col_3": 1,
    "col_4": 2,
    "col_5": "2 or 3",
    "col_6": 3,
    "col_7": "2 or 3",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 895,
    "col_2": "Pick out the in correct type of function in <algorithm> header file.",
    "col_3": "Partitions",
    "col_4": "Sort",
    "col_5": "Merge",
    "col_6": "Join",
    "col_7": "Join",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 896,
    "col_2": "What type of algorithm is not available in creating our own STL style algorithms?",
    "col_3": "copy_if()",
    "col_4": "remove_copy_if()",
    "col_5": "sort",
    "col_6": "remove_copy()",
    "col_7": "copy_if()",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 897,
    "col_2": "What is meant by hash tables in C++?",
    "col_3": "Array data structure",
    "col_4": "Keyed array data structure",
    "col_5": "Data structure",
    "col_6": "Linear probing",
    "col_7": "Keyed array data structure",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 898,
    "col_2": "What is the use of includes function in c++?",
    "col_3": "Compares two ranges of data",
    "col_4": "Compares two sorted ranges of data",
    "col_5": "Includes a new element in the range",
    "col_6": "Includes a new element in the end",
    "col_7": "Compares two sorted ranges of data",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 899,
    "col_2": "How many parameters are required for sort_heap function?",
    "col_3": 1,
    "col_4": 2,
    "col_5": "2 or 3",
    "col_6": 3,
    "col_7": "2 or 3",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 900,
    "col_2": "How many categories of iterators are there in c++?",
    "col_3": 2,
    "col_4": 4,
    "col_5": 5,
    "col_6": 3,
    "col_7": 5,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 901,
    "col_2": "Which of the following can serve as random-access iterator?",
    "col_3": "Memory pointer",
    "col_4": "Object pointer",
    "col_5": "Class pointer",
    "col_6": "Memory & Class pointer",
    "col_7": "Object pointer",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 902,
    "col_2": "What kind of pattern is iterator pattern?",
    "col_3": "Design pattern",
    "col_4": "Sequence pattern",
    "col_5": "Adapter pattern",
    "col_6": "Star pattern",
    "col_7": "Design pattern",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 903,
    "col_2": "In which type of semantics does c++ implements iterator?",
    "col_3": "Memory",
    "col_4": "Size",
    "col_5": "Pointer",
    "col_6": "Value",
    "col_7": "Pointer",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 904,
    "col_2": "By using which operator does point to next element is represent initerator?",
    "col_3": "++",
    "col_4": "--",
    "col_5": "+-",
    "col_6": "-+-",
    "col_7": "++",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 905,
    "col_2": "What is the use of checked iterators?",
    "col_3": "Overwrite the bounds of your container",
    "col_4": "Not allow you to overwrite the bounds of your container",
    "col_5": "It will check the list value",
    "col_6": "Overwrite the bounds of your iterators",
    "col_7": "Not allow you to overwrite the bounds of your container",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 906,
    "col_2": "What will happen if the iterator is unchecked?",
    "col_3": "Arising of compiler warnings",
    "col_4": "Unchecked behavior on program",
    "col_5": "Nothing will execute",
    "col_6": "Arising of compiler warnings & Unchecked behavior on program",
    "col_7": "Arising of compiler warnings & Unchecked behavior on program",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 907,
    "col_2": "How many adaptors support the checked iterators?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 2,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 908,
    "col_2": "What does the checked iterator allow you to find?",
    "col_3": "Warnings",
    "col_4": "Compile time error",
    "col_5": "Run time error",
    "col_6": "Warnings & Run time error",
    "col_7": "Run time error",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 909,
    "col_2": "What kind of errors do checked iterators detect?",
    "col_3": "Uninitialized iterators",
    "col_4": "Initialized iterators",
    "col_5": "Range access",
    "col_6": "Both Uninitialized iterators and range access",
    "col_7": "Both Uninitialized iterators and range access",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 910,
    "col_2": "Where are allocators used?",
    "col_3": "Allocation of memory",
    "col_4": "Deallocation of memory",
    "col_5": "Used for pointers",
    "col_6": "Both Allocation & Deallocation of memory",
    "col_7": "Both Allocation & Deallocation of memory",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 911,
    "col_2": "Where are allocators implemented?",
    "col_3": "Template library",
    "col_4": "Standard library",
    "col_5": "C++ code library",
    "col_6": "String library",
    "col_7": "Standard library",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 912,
    "col_2": "Which operator is used to allocate the memory?",
    "col_3": "=",
    "col_4": "+",
    "col_5": "new",
    "col_6": "free",
    "col_7": "new",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 913,
    "col_2": "Which operator is used to deallocate the memory?",
    "col_3": "destroy",
    "col_4": "free",
    "col_5": "empty",
    "col_6": "insert",
    "col_7": "free",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 914,
    "col_2": "Which header file is used to manipulate the allocater?",
    "col_3": "allocater",
    "col_4": "memory",
    "col_5": "object",
    "col_6": "iterator",
    "col_7": "memory",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 915,
    "col_2": "What is the use of reference member type in allocator?",
    "col_3": "Point to an element",
    "col_4": "Quantities of element",
    "col_5": "Reference to an element",
    "col_6": "Sequence of an element",
    "col_7": "Reference to an element",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 916,
    "col_2": "What is the correct syntax for declaring an allocator?",
    "col_3": "template < class T > class allocator;",
    "col_4": "template < class T > class;",
    "col_5": "template class allocator;",
    "col_6": "template class()",
    "col_7": "template < class T > class allocator;",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 917,
    "col_2": "What are Iterators?",
    "col_3": "STL component used to point a memory address of a container",
    "col_4": "STL component used for vectors",
    "col_5": "STL component used to call functions efficiently",
    "col_6": "STL component used to define template classes",
    "col_7": "STL component used to point a memory address of a container",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 918,
    "col_2": "Which function is used increment the iterator by a particular value?",
    "col_3": "next()",
    "col_4": "advance()",
    "col_5": "prev()",
    "col_6": "move()",
    "col_7": "advance()",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 919,
    "col_2": "How many types of Iterators are there?",
    "col_3": 5,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 5,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 920,
    "col_2": "Pick the correct statement.",
    "col_3": "Input iterator moves sequentially forward",
    "col_4": "Input iterator moves sequentially backward",
    "col_5": "Input iterator moves in both direction",
    "col_6": "Input iterator moves sequentially downwards",
    "col_7": "Input iterator moves sequentially forward",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 921,
    "col_2": "Which of the following is correct about Input Iterators?",
    "col_3": "Input iterators can be used with all relational operators",
    "col_4": "Input iterators can work with arithmetic operators",
    "col_5": "No value can be assigned to the location pointed by Input Iterator",
    "col_6": "Input iterators can work with sequence operators",
    "col_7": "No value can be assigned to the location pointed by Input Iterator",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 922,
    "col_2": "Which of the following is correct about Input Iterators?",
    "col_3": "They cannot be decremented",
    "col_4": "Cannot be used in multi-pass algorithms",
    "col_5": "Can only be incremented",
    "col_6": "All of the mentioned",
    "col_7": "All of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 923,
    "col_2": "Which of the following is correct?",
    "col_3": "Input Iterators are used for assigning",
    "col_4": "Output Iterators are used for assigning",
    "col_5": "Both Input and Output Iterators are used for accessing",
    "col_6": "Both Input and Output Iterators are used for assigning",
    "col_7": "Output Iterators are used for assigning",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 924,
    "col_2": "Which of the following is an advantage of Forward iterator over input and output iterator?",
    "col_3": "Can be used as both accessing and assigning iterator",
    "col_4": "Forward iterator can be incremented or decremented",
    "col_5": "Can be used with relational operators also",
    "col_6": "Can be used with arithmetic operators also",
    "col_7": "Can be used as both accessing and assigning iterator",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 925,
    "col_2": "What are Bi-directional iterators?",
    "col_3": "Iterator same as Forward Iterator",
    "col_4": "Forward Iterator that can be used in both directions",
    "col_5": "Iterator that can only be used to access the sequence from both sides",
    "col_6": "Iterator that can only be used to assign the sequence from both sides",
    "col_7": "Forward Iterator that can be used in both directions",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 926,
    "col_2": "What are Random-access Iterators?",
    "col_3": "Iterators that can be used to access elements at an arbitrary offset position",
    "col_4": "Same as Bi-directional iterator",
    "col_5": "Input iterator with the additional property of random access",
    "col_6": "Output iterator with the additional property of random access",
    "col_7": "Iterators that can be used to access elements at an arbitrary offset position",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 927,
    "col_2": "Which of the header file is used to implement algorithms provided by C++ STL?",
    "col_3": "<algorithm>",
    "col_4": "<header>",
    "col_5": "<algos>",
    "col_6": "<Algorithm>",
    "col_7": "<algorithm>",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 928,
    "col_2": "How many types of sequence operations are provided by the C++ algorithm STL?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 2,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 929,
    "col_2": "Which of the following is a Modifying Sequence Operation?",
    "col_3": "all_of()",
    "col_4": "any_of()",
    "col_5": "equal()",
    "col_6": "swap()",
    "col_7": "swap()",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 930,
    "col_2": "Which of the following is a Non-modifying Sequence Operation?",
    "col_3": "swap()",
    "col_4": "transform()",
    "col_5": "remove()",
    "col_6": "search()",
    "col_7": "search()",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 931,
    "col_2": "What is the use of random_shuffle() function of STL algorithm?",
    "col_3": "To generate the random sequence in a range",
    "col_4": "To generate a sequence in a given range and arrange them in random order",
    "col_5": "To rearrange given sequence randomly",
    "col_6": "To select any random number from the given sequence.",
    "col_7": "To rearrange given sequence randomly",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 932,
    "col_2": "What is the property of stable sort function provided by the STL algorithm?",
    "col_3": "sorts the elements of a sequence in ascending order preserving the relative order of equivalent elements",
    "col_4": "sorts the elements of a sequence in descending order preserving the relative order of equivalent elements",
    "col_5": "arranges the sequence randomly preserving the relative order of equivalent elements",
    "col_6": "same as sort function of STL algorithm",
    "col_7": "sorts the elements of a sequence in ascending order preserving the relative order of equivalent elements",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 933,
    "col_2": "What is the property of partial sort function provided by the STL algorithm?",
    "col_3": "sorts the elements before the middle element in ascending order and remaining elements are left without any specific order",
    "col_4": "sorts the elements before the middle element in descending order and remaining elements are left without any specific order",
    "col_5": "sorts the elements after the middle element in ascending order and remaining elements are left without any specific order",
    "col_6": "sorts the elements after the middle element in descending order and remaining elements are left without any specific order",
    "col_7": "sorts the elements before the middle element in ascending order and remaining elements are left without any specific order",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 934,
    "col_2": "Which function can be used to find the sum of a vector container?",
    "col_3": "findsum()",
    "col_4": "accumulate()",
    "col_5": "calcsum()",
    "col_6": "checksum()",
    "col_7": "accumulate()",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 935,
    "col_2": "Which header file is required to use accumulate() function?",
    "col_3": "<algorithm>",
    "col_4": "<numeric>",
    "col_5": "<vector>",
    "col_6": "<iostream>",
    "col_7": "<numeric>",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 936,
    "col_2": "What are functors in C++?",
    "col_3": "Objects of a class which are treated as functions",
    "col_4": "Objects that are used to call the function of other classes",
    "col_5": "Functions that are called using pointer objects",
    "col_6": "Functions that are called only once in a program",
    "col_7": "Objects of a class which are treated as functions",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 937,
    "col_2": "Which of the following operators are overloaded for functors?",
    "col_3": [],
    "col_4": "()",
    "col_5": "<<",
    "col_6": ">>",
    "col_7": "()",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 938,
    "col_2": "What is the correct function prototype of () operator overloading?",
    "col_3": "return_type operator(arguments)();",
    "col_4": "return_type operator(arguments);",
    "col_5": "return_type operator()(arguments);",
    "col_6": "return_type operator(Class_name)(arguments);",
    "col_7": "return_type operator()(arguments);",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 939,
    "col_2": "Which of the following is correct about Functors?",
    "col_3": "Functors should not be declared outside the main function",
    "col_4": "Overloaded operator () function is not a member of the class",
    "col_5": "Functors should be declared global",
    "col_6": "Functors have a state",
    "col_7": "Functors have a state",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 940,
    "col_2": "Which of te following is a built-in example of functors in C++?",
    "col_3": "mltiplication<T> f(a1, a2);",
    "col_4": "add<T> f(a1, a2);",
    "col_5": "subtract<T> f(a1, a2);",
    "col_6": "plus<T> f(a1, a2);",
    "col_7": "plus<T> f(a1, a2);",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 941,
    "col_2": "Which of the following header file is required to use in-bulit functors of C++?",
    "col_3": "<any>",
    "col_4": "<fucntional>",
    "col_5": "<functor>",
    "col_6": "<function>",
    "col_7": "<fucntional>",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 942,
    "col_2": "What are unary functors?",
    "col_3": "Functors that accepts only one parameter",
    "col_4": "Functors that accepts two parameters",
    "col_5": "Functors that accepts more than one parameters",
    "col_6": "Functors that accepts other than a specific type of parameter",
    "col_7": "Functors that accepts only one parameter",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 943,
    "col_2": "What are binary functors?",
    "col_3": "Functors that accepts only one parameter",
    "col_4": "Functors that accepts more than one parameters",
    "col_5": "Functors that accepts two parameters",
    "col_6": "Functors that accepts other than a specific type of parameter",
    "col_7": "Functors that accepts two parameters",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 944,
    "col_2": "How many ways are there to use functors?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 2,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 945,
    "col_2": "Which of the following is a logical unary functor?",
    "col_3": "logical_or<T> f;",
    "col_4": "logical_and<T> f;",
    "col_5": "logical_not<T> f;",
    "col_6": "negate<T> f;",
    "col_7": "logical_not<T> f;",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 946,
    "col_2": "What of the following is the equivalent statement for the functor call, x = f(arg1, arg2);  where f is a functor and arg1 and arg2 are the arguments required by the functors?",
    "col_3": "f.call(arg1, arg2);",
    "col_4": "f.operator()(arg1, arg2);",
    "col_5": "f.operator(arg1, arg2);",
    "col_6": "f.operator(arg1, arg2)();",
    "col_7": "f.operator()(arg1, arg2);",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 947,
    "col_2": "Which is an instantiation of the basic_string class template?",
    "col_3": "Character",
    "col_4": "String class",
    "col_5": "Memory",
    "col_6": "Iterator",
    "col_7": "String class",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 948,
    "col_2": "Which character is used to terminate the string?",
    "col_3": "$",
    "col_4": "Null",
    "col_5": "Empty",
    "col_6": "@",
    "col_7": "Null",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 949,
    "col_2": "How does the strings are stored in the memory?",
    "col_3": "Contiguous",
    "col_4": "Non-contiguous",
    "col_5": "Null",
    "col_6": "sequence",
    "col_7": "Contiguous",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 950,
    "col_2": "Where are the strings stored?",
    "col_3": "Stack",
    "col_4": "Heap",
    "col_5": "Both Stack & Heap",
    "col_6": "Queue",
    "col_7": "Both Stack & Heap",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 951,
    "col_2": "What will happen if a string is empty?",
    "col_3": "It can't be created",
    "col_4": "Raises an error",
    "col_5": "It can be used",
    "col_6": "It cannot be used",
    "col_7": "It can be used",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 952,
    "col_2": "Which header file is used to manipulate the string?",
    "col_3": "iostream",
    "col_4": "iomanip",
    "col_5": "string",
    "col_6": "container",
    "col_7": "string",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 953,
    "col_2": "How many maximum number of parameters does a string constructor can take?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 3,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 954,
    "col_2": "Which constant member functions does not modify the string?",
    "col_3": "bool empty()",
    "col_4": "assign",
    "col_5": "append",
    "col_6": "delete",
    "col_7": "bool empty()",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 955,
    "col_2": "What is the difference between unsigned int length() and unsigned int size()?",
    "col_3": "Returns a different value",
    "col_4": "They are same",
    "col_5": "Returns a different value but they are same",
    "col_6": "Returns a length",
    "col_7": "They are same",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 956,
    "col_2": "How many parameters can a resize method take?",
    "col_3": 1,
    "col_4": 2,
    "col_5": "1 or 2",
    "col_6": 2,
    "col_7": "1 or 2",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 957,
    "col_2": "Where are standard C libraries defined in C++?",
    "col_3": "Container",
    "col_4": "std namespace",
    "col_5": "list",
    "col_6": "iterators",
    "col_7": "std namespace",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 958,
    "col_2": "Which of the following have their changes in their declaration related to constness of parameter?",
    "col_3": "strchr",
    "col_4": "string",
    "col_5": "memory",
    "col_6": "strcybrk",
    "col_7": "strchr",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 959,
    "col_2": "How many elements does a floating point number is composed of?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 4,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 960,
    "col_2": "How does the limits.h header file can be represented in C++?",
    "col_3": "limits",
    "col_4": "limit",
    "col_5": "climits",
    "col_6": "dlimits",
    "col_7": "climits",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 961,
    "col_2": "Pick out the correct syntax of the header file that can be used with C++.",
    "col_3": "#include <float>",
    "col_4": "#include <float.h>",
    "col_5": "Both #include <float> & #include <float.h>",
    "col_6": "#include <flot.h>",
    "col_7": "#include <float.h>",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 962,
    "col_2": "How many groups of output of operation are there in c++?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 2,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 963,
    "col_2": "Pick out the correct objects about the instantiation of output stream.",
    "col_3": "cout",
    "col_4": "cerr",
    "col_5": "clog",
    "col_6": "all of the mentioned",
    "col_7": "all of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 964,
    "col_2": "What is meant by ofstream in c++?",
    "col_3": "Writes to a file",
    "col_4": "Reads from a file",
    "col_5": "Writes to a file & Reads from a file",
    "col_6": "delete a file",
    "col_7": "Writes to a file",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 965,
    "col_2": "How many types of output stream classes are there in c++?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 3,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 966,
    "col_2": "What must be specified when we construct an object of class ostream?",
    "col_3": "stream",
    "col_4": "streambuf",
    "col_5": "memory",
    "col_6": "steamostream",
    "col_7": "streambuf",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 967,
    "col_2": "Which operator is used for input stream?",
    "col_3": ">",
    "col_4": ">>",
    "col_5": "<",
    "col_6": "<<",
    "col_7": ">>",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 968,
    "col_2": "Where does a cin stops it extraction of data?",
    "col_3": "By seeing a blank space",
    "col_4": "By seeing (",
    "col_5": "By seeing a blank space & (",
    "col_6": "By seeing <",
    "col_7": "By seeing a blank space",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 969,
    "col_2": "Which is used to get the input during runtime?",
    "col_3": "cout",
    "col_4": "cin",
    "col_5": "coi",
    "col_6": "cinout",
    "col_7": "cin",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 970,
    "col_2": "How many parameters are there in getline function?",
    "col_3": 1,
    "col_4": 2,
    "col_5": "2 or 3",
    "col_6": 3,
    "col_7": "2 or 3",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 971,
    "col_2": "What can be used to input a string with blank space?",
    "col_3": "inline",
    "col_4": "getline",
    "col_5": "putline",
    "col_6": "setline",
    "col_7": "getline",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 972,
    "col_2": "When will the cin can start processing of input?",
    "col_3": "After pressing return key",
    "col_4": "BY pressing blank space",
    "col_5": "After pressing return key & BY pressing blank space",
    "col_6": "BY pressing delete space",
    "col_7": "After pressing return key",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 973,
    "col_2": "Which is used for formatting purpose in c++?",
    "col_3": "Whitespace",
    "col_4": "Container",
    "col_5": "&",
    "col_6": "Vector",
    "col_7": "Whitespace",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 974,
    "col_2": "How many number of spaces should be set in default tab?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 4,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 975,
    "col_2": "What can be improved by formatting the source code?",
    "col_3": "Memory",
    "col_4": "Address",
    "col_5": "User interface",
    "col_6": "Iterator",
    "col_7": "User interface",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 976,
    "col_2": "Choose the correct formatted code.",
    "col_3": "int a = 5;",
    "col_4": "int a=5;",
    "col_5": "int a =5;",
    "col_6": "int a5;",
    "col_7": "int a = 5;",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 977,
    "col_2": "Which function allows you to set minimum width for the next input?",
    "col_3": "setfill",
    "col_4": "setw",
    "col_5": "setwidth",
    "col_6": "setheight",
    "col_7": "setw",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 978,
    "col_2": "What is the use of the function \"showbase\"?",
    "col_3": "Indicate the base used",
    "col_4": "Indicate the variable",
    "col_5": "Indicate the base used & variable",
    "col_6": "Indicate the derived",
    "col_7": "Indicate the base used",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 979,
    "col_2": "Which operator is used to insert the data into file?",
    "col_3": ">>",
    "col_4": "<<",
    "col_5": "<",
    "col_6": ">",
    "col_7": "<<",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 980,
    "col_2": "Which function is used to position back from the end of file object?",
    "col_3": "seekg",
    "col_4": "seekp",
    "col_5": "both seekg & seekp",
    "col_6": "seekf",
    "col_7": "seekg",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 981,
    "col_2": "How many objects are used for input and output to a string?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 3,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 982,
    "col_2": "Which member function is used to determine whether the stream object is currently associated with a file?",
    "col_3": "is_open",
    "col_4": "buf",
    "col_5": "string",
    "col_6": "is_out",
    "col_7": "is_open",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 983,
    "col_2": "Which header file is used for reading and writing to a file?",
    "col_3": "#include<iostream>",
    "col_4": "#include<fstream>",
    "col_5": "#include<file>",
    "col_6": "#include<fe>",
    "col_7": "#include<fstream>",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 984,
    "col_2": "Which one is always faster in writing on C++?",
    "col_3": "Writing to a file",
    "col_4": "Writing to memory",
    "col_5": "Reading from the network",
    "col_6": "Deleting a file",
    "col_7": "Writing to memory",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 985,
    "col_2": "How many tests are available in read and write operations?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 2,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 986,
    "col_2": "What will act as a intermediate between i/o operations and physical file?",
    "col_3": "Memory",
    "col_4": "Ram",
    "col_5": "Stream buffer",
    "col_6": "Storage",
    "col_7": "Stream buffer",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 987,
    "col_2": "By using which function does the buffer are automatically flushed?",
    "col_3": "fopen",
    "col_4": "copy",
    "col_5": "compare",
    "col_6": "fclose",
    "col_7": "fclose",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 988,
    "col_2": "How many parameters are available in the function setbuf?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 2,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 989,
    "col_2": "What is the main feature of locale in C++?",
    "col_3": "Sustainability",
    "col_4": "Portability",
    "col_5": "Reliability",
    "col_6": "Sustainability & Reliability",
    "col_7": "Portability",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 990,
    "col_2": "Which objects information is loaded in locale object?",
    "col_3": "facet object",
    "col_4": "instead object",
    "col_5": "Both facet & instead object",
    "col_6": "secant object",
    "col_7": "facet object",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 991,
    "col_2": "How many categories are available in facets?",
    "col_3": 4,
    "col_4": 5,
    "col_5": 6,
    "col_6": 3,
    "col_7": 6,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 992,
    "col_2": "What kind of locale does every program is having in C++?",
    "col_3": "local locale",
    "col_4": "global locale",
    "col_5": "temp locale",
    "col_6": "set locale",
    "col_7": "global locale",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 993,
    "col_2": "What will the monetary facet will do?",
    "col_3": "Handle formatting and parsing of monetary values",
    "col_4": "Handle formatting and parsing of character values",
    "col_5": "Parsing of character values",
    "col_6": "Deleting a character values",
    "col_7": "Handle formatting and parsing of monetary values",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 994,
    "col_2": "Which header file is used with input and output operations of C in C++?",
    "col_3": "stdio.h",
    "col_4": "cstdio",
    "col_5": "iostream",
    "col_6": "streamio",
    "col_7": "cstdio",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 995,
    "col_2": "Which will be used with physical devices to interact from C++ program?",
    "col_3": "Programs",
    "col_4": "Library",
    "col_5": "Streams",
    "col_6": "Iterators",
    "col_7": "Streams",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 996,
    "col_2": "How many streams are automatically created when executing a program?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 3,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 997,
    "col_2": "How many indicators are available in c++?",
    "col_3": 4,
    "col_4": 3,
    "col_5": 2,
    "col_6": 1,
    "col_7": 3,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 998,
    "col_2": "What is the benefit of c++ input and output over c input and output?",
    "col_3": "Type safety",
    "col_4": "Exception",
    "col_5": "Both Type safety & Exception",
    "col_6": "Sequence container",
    "col_7": "Type safety",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 999,
    "col_2": "To which type does the numeric limits are suitable?",
    "col_3": "Character types",
    "col_4": "Mixed type",
    "col_5": "Arithmetic types",
    "col_6": "Relational types",
    "col_7": "Arithmetic types",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1000,
    "col_2": "Where does the member should be defined if it is used in the program?",
    "col_3": "Namespace scope",
    "col_4": "Character scope",
    "col_5": "Namespace & Character scope",
    "col_6": "Directional scope",
    "col_7": "Namespace scope",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1001,
    "col_2": "What will the max function in the numeric limit will return for type float?",
    "col_3": "Maximum finite value for a float type",
    "col_4": "Maximum finite value",
    "col_5": "Minimum finite value",
    "col_6": "Minimum float value",
    "col_7": "Maximum finite value for a float type",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1002,
    "col_2": "Which header file is used for the numeric limits in C++?",
    "col_3": "<iostream>",
    "col_4": "<limits>",
    "col_5": "<number>",
    "col_6": "<digit>",
    "col_7": "<limits>",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1003,
    "col_2": "Pick out the incorrect static function member in numeric limits.",
    "col_3": "denorm_min",
    "col_4": "digits",
    "col_5": "infinity",
    "col_6": "max_finite",
    "col_7": "max_finite",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1004,
    "col_2": "With which does the trigonometric functions work with angles in c++?",
    "col_3": "Degrees",
    "col_4": "Radians",
    "col_5": "Both Degrees & Radians",
    "col_6": "Celsius",
    "col_7": "Radians",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1005,
    "col_2": "Which header file is required for manipulation of math functions in c++?",
    "col_3": "cmath",
    "col_4": "maths",
    "col_5": "math",
    "col_6": "dmath",
    "col_7": "cmath",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1006,
    "col_2": "How many macros are used by mathematical functions in the header file <cerrno>?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 3,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1007,
    "col_2": "Which of the following mathematical function is overloaded in <complex> and <valarray>?",
    "col_3": "cos",
    "col_4": "tan",
    "col_5": "sin",
    "col_6": "mod",
    "col_7": "tan",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1008,
    "col_2": "How many parameters are used in frexp function?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 2,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1009,
    "col_2": "Which of the following library is used to do vector arithmetic?",
    "col_3": "Boost",
    "col_4": "Time",
    "col_5": "OpenGL",
    "col_6": "OpenDL",
    "col_7": "Boost",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1010,
    "col_2": "Which header file is used to manipulate the vector algebra in c++?",
    "col_3": "math",
    "col_4": "cmath",
    "col_5": "vmath",
    "col_6": "dmath",
    "col_7": "vmath",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1011,
    "col_2": "What type of reference should be used in vector arithmetic?",
    "col_3": "dynamic",
    "col_4": "const",
    "col_5": "both dynamic & const",
    "col_6": "static",
    "col_7": "const",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1012,
    "col_2": "What will be the type of output of vector cross product?",
    "col_3": "Scalar",
    "col_4": "Vector",
    "col_5": "Both Scalar & Vector",
    "col_6": "Linear",
    "col_7": "Vector",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1013,
    "col_2": "Which function is used to optimize the space in vector?",
    "col_3": "at",
    "col_4": "bool",
    "col_5": "operator",
    "col_6": "operand",
    "col_7": "bool",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1014,
    "col_2": "What is the use of vector arithmetic in c++?",
    "col_3": "Computer graphics",
    "col_4": "Computer booting",
    "col_5": "Both Computer graphics & Computer booting",
    "col_6": "Computer Networks",
    "col_7": "Computer graphics",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1015,
    "col_2": "Which header file is used to operate on numeric sequences?",
    "col_3": "number",
    "col_4": "numeric",
    "col_5": "algorithm",
    "col_6": "digit",
    "col_7": "numeric",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1016,
    "col_2": "Which mathematics library is used for vector manipulation in c++?",
    "col_3": "cli++",
    "col_4": "vec++",
    "col_5": "blitz++",
    "col_6": "stac+++",
    "col_7": "blitz++",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1017,
    "col_2": "What is the use of accumulate function in a numeric library?",
    "col_3": "Returns the number",
    "col_4": "Returns the result of accumulating all the values in the range",
    "col_5": "Returns the number & result",
    "col_6": "Return the characters",
    "col_7": "Returns the result of accumulating all the values in the range",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1018,
    "col_2": "How many parameters are available in partial_sum function in c++?",
    "col_3": 2,
    "col_4": 3,
    "col_5": "2 or 3",
    "col_6": "3 or 4",
    "col_7": "3 or 4",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1019,
    "col_2": "What is the default operation of adjacent_difference function in numeric library?",
    "col_3": "Difference",
    "col_4": "Addition",
    "col_5": "Multiplication",
    "col_6": "Subtraction",
    "col_7": "Difference",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1020,
    "col_2": "Which header file is used to create the pseudo random generator?",
    "col_3": "random",
    "col_4": "cstdlib",
    "col_5": "rand",
    "col_6": "both random and cstdlib",
    "col_7": "both random and cstdlib",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1021,
    "col_2": "Which is a constant defined in <cstdlib> header file?",
    "col_3": "RAND_MAX",
    "col_4": "Rand",
    "col_5": "Srand",
    "col_6": "Blitz",
    "col_7": "RAND_MAX",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1022,
    "col_2": "How many parameters are available in srand function?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 1,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1023,
    "col_2": "Which operator is used to produce a certain number in a specific range?",
    "col_3": "$",
    "col_4": "%",
    "col_5": "modulo operator",
    "col_6": "both % and modulo operator",
    "col_7": "both % and modulo operator",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1024,
    "col_2": "Which can be used to create a random number without duplication?",
    "col_3": "Character",
    "col_4": "Time",
    "col_5": "Both Character & Time",
    "col_6": "Date",
    "col_7": "Time",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1025,
    "col_2": "Which header file is required to use file I/O operations?",
    "col_3": "<ifstream>",
    "col_4": "<ostream>",
    "col_5": "<fstream>",
    "col_6": "<iostream>",
    "col_7": "<fstream>",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1026,
    "col_2": "Which of the following is used to create an output stream?",
    "col_3": "ofstream",
    "col_4": "ifstream",
    "col_5": "iostream",
    "col_6": "fsstream",
    "col_7": "ofstream",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1027,
    "col_2": "Which of the following is used to create a stream that performs both input and output operations?",
    "col_3": "ofstream",
    "col_4": "ifstream",
    "col_5": "iostream",
    "col_6": "fstream",
    "col_7": "fstream",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1028,
    "col_2": "Which of the following is not used as a file opening mode?",
    "col_3": "ios::trunc",
    "col_4": "ios::binary",
    "col_5": "ios::in",
    "col_6": "ios::ate",
    "col_7": "ios::trunc",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1029,
    "col_2": "By default, all the files in C++ are opened in _________ mode.",
    "col_3": "Text",
    "col_4": "Binary",
    "col_5": "ISCII",
    "col_6": "VTC",
    "col_7": "Text",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1030,
    "col_2": "What is the use of ios::trunc mode?",
    "col_3": "To open a file in input mode",
    "col_4": "To open a file in output mode",
    "col_5": "To truncate an existing file to half",
    "col_6": "To truncate an existing file to zero",
    "col_7": "To truncate an existing file to zero",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1031,
    "col_2": "Which of the following is the default mode of the opening using the ofstream class?",
    "col_3": "ios::in",
    "col_4": "ios::out",
    "col_5": "ios::app",
    "col_6": "ios::trunc",
    "col_7": "ios::out",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1032,
    "col_2": "What is the return type open() method?",
    "col_3": "int",
    "col_4": "char",
    "col_5": "bool",
    "col_6": "float",
    "col_7": "bool",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1033,
    "col_2": "Which of the following is not used to seek file pointer?",
    "col_3": "ios::set",
    "col_4": "ios::end",
    "col_5": "ios::cur",
    "col_6": "ios::beg",
    "col_7": "ios::set",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1034,
    "col_2": "Which of the following is the default mode of the opening using the ifstream class?",
    "col_3": "ios::in",
    "col_4": "ios::out",
    "col_5": "ios::app",
    "col_6": "ios::trunc",
    "col_7": "ios::in",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1035,
    "col_2": "Which function is used in C++ to get the current position of file pointer in a file?",
    "col_3": "tell_p()",
    "col_4": "get_pos()",
    "col_5": "get_p()",
    "col_6": "tell_pos()",
    "col_7": "tell_p()",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1036,
    "col_2": "Which function is used to reposition the file pointer?",
    "col_3": "moveg()",
    "col_4": "seekg()",
    "col_5": "changep()",
    "col_6": "go_p()",
    "col_7": "seekg()",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1037,
    "col_2": "Which of the following is used to move the file pointer to start of a file?",
    "col_3": "ios::beg",
    "col_4": "ios::start",
    "col_5": "ios::cur",
    "col_6": "ios::first",
    "col_7": "ios::beg",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1038,
    "col_2": "What is lambda expression in C++?",
    "col_3": "A technique of C++ that allows us to write inline functions without a name",
    "col_4": "A technique of C++ that allows us to write overloaded functions",
    "col_5": "A technique of C++ that allows us to write functions that are called more than once",
    "col_6": "A technique of C++ that allows us to write functions without parameters",
    "col_7": "A technique of C++ that allows us to write inline functions without a name",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1039,
    "col_2": "What is the syntax of defining lambda expression?",
    "col_3": "[capture clause](parameters) -> return_type { body of the function }",
    "col_4": "[parameters](capture clause) -> return_type { body of the function }",
    "col_5": "[parameters:capture clause]() -> return_type { body of the function }",
    "col_6": "[capture clause:parameters]() -> return_type { body of the function }",
    "col_7": "[capture clause](parameters) -> return_type { body of the function }",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1040,
    "col_2": "What is the correct statement about lambda expression?",
    "col_3": "The return type of lambda expression can be neglected in some cases",
    "col_4": "The return type of lambda expression must be specified in all cases",
    "col_5": "Lambda expression should be very large functions",
    "col_6": "Lambda expression is also available in C",
    "col_7": "The return type of lambda expression can be neglected in some cases",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1041,
    "col_2": "In how many ways we can capture the external variables in the lambda expression?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 3,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1042,
    "col_2": "Which of the following operator is used to capture all the external variable by reference?",
    "col_3": "&",
    "col_4": "=",
    "col_5": "*",
    "col_6": "&&",
    "col_7": "&",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1043,
    "col_2": "Which of the following operator is used to capture all the external variable by value?",
    "col_3": "&",
    "col_4": "=",
    "col_5": "*",
    "col_6": "&&",
    "col_7": "=",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1044,
    "col_2": "Which is the correct syntax of capturing a variable 'X' by reference and other variable 'Y' by value in lambda expression?",
    "col_3": "[&X, Y]",
    "col_4": "[X, &y]",
    "col_5": "[X, Y]",
    "col_6": "[&x, &Y]",
    "col_7": "[&X, Y]",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1045,
    "col_2": "What are command line arguments?",
    "col_3": "Arguments passed to main() function",
    "col_4": "Arguments passed to any function",
    "col_5": "Arguments passed to class functions",
    "col_6": "Arguments passed to structure functions",
    "col_7": "Arguments passed to main() function",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1046,
    "col_2": "To use command line arguments in C++, how many parameters are passed to the main function?",
    "col_3": 1,
    "col_4": 2,
    "col_5": 3,
    "col_6": 4,
    "col_7": 2,
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1047,
    "col_2": "What is the signature of math in function using command line arguments?",
    "col_3": "int main(int argc, char const *argv[]);",
    "col_4": "int main(int argc, char const **argv);",
    "col_5": "int main(int argc, char **argv);",
    "col_6": "all of the mentioned",
    "col_7": "all of the mentioned",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1048,
    "col_2": "What does the first parameter of the main function represent?",
    "col_3": "Number of command line arguments",
    "col_4": "List of command line arguments",
    "col_5": "Dictionary of command line arguments",
    "col_6": "Stack of command line arguments",
    "col_7": "Number of command line arguments",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1049,
    "col_2": "What does the second parameter of the main function represent?",
    "col_3": "Number of command line arguments",
    "col_4": "List of command line arguments",
    "col_5": "Dictionary of command line arguments",
    "col_6": "Stack of command line arguments",
    "col_7": "List of command line arguments",
    "col_8": "None",
    "col_9": 0
  },
  {
    "col_1": 1050,
    "col_2": "Which of the following is correct about the first parameter of the main function?",
    "col_3": "First argument is of int type",
    "col_4": "Stores the count of command line arguments",
    "col_5": "First argument is non-negative",
    "col_6": "All of the mentioned",
    "col_7": "All of the mentioned",
    "col_8": "None",
    "col_9": 0
  }
]